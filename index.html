<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Audio Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background-color: #2a2a2a;
            border-bottom: 1px solid #3a3a3a;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar-group {
            display: flex;
            gap: 4px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid #3a3a3a;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-label {
            font-size: 11px;
            color: #888;
            margin-right: 4px;
        }

        button {
            background-color: #3a3a3a;
            color: #e0e0e0;
            border: 1px solid #4a4a4a;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background-color 0.15s;
        }

        button:hover:not(:disabled) {
            background-color: #4a4a4a;
        }

        button:active:not(:disabled) {
            background-color: #5a5a5a;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.primary {
            background-color: #2563eb;
            border-color: #3b82f6;
        }

        button.primary:hover:not(:disabled) {
            background-color: #3b82f6;
        }

        button.transport {
            width: 40px;
            font-size: 16px;
            padding: 6px;
        }

        button.transport.playing {
            background-color: #059669;
            border-color: #10b981;
        }

        button.transport.loop-active {
            background-color: #7c3aed;
            border-color: #8b5cf6;
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }

        /* Editor area (waveform + spectrogram) */
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Waveform container */
        .waveform-container {
            flex: 3;
            position: relative;
            background-color: #1a1a1a;
            overflow: hidden;
            min-height: 120px;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Spectrogram container */
        .spectrogram-container {
            flex: 1;
            position: relative;
            background-color: #0a0a0a;
            border-top: 1px solid #3a3a3a;
            min-height: 80px;
            max-height: 150px;
        }

        #spectrogramCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .spectrogram-label {
            position: absolute;
            top: 4px;
            left: 8px;
            font-size: 10px;
            color: #666;
        }

        .spectrogram-fft {
            position: absolute;
            bottom: 4px;
            right: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .spectrogram-fft-label {
            font-size: 9px;
            color: #666;
        }

        /* Meters panel */
        .meters-panel {
            width: 140px;
            background-color: #222;
            border-left: 1px solid #3a3a3a;
            padding: 6px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .meter {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .meter-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .meter-value {
            font-size: 14px;
            font-family: monospace;
            font-weight: 600;
            color: #4ade80;
        }

        .meter-value.warning {
            color: #fbbf24;
        }

        .meter-value.danger {
            color: #ef4444;
        }

        .meter-bar-container {
            height: 4px;
            background-color: #1a1a1a;
            border-radius: 2px;
            overflow: hidden;
        }

        .meter-bar {
            height: 100%;
            background: linear-gradient(to right, #4ade80, #fbbf24, #ef4444);
            border-radius: 2px;
            transition: width 0.05s;
        }

        .meter-unit {
            font-size: 8px;
            color: #666;
        }

        /* File stats (non-realtime) */
        .file-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2px 0;
            font-size: 10px;
        }

        .file-stat-label {
            color: #888;
            font-size: 9px;
        }

        .file-stat-value {
            color: #e0e0e0;
            font-family: monospace;
            font-size: 10px;
        }

        .stats-divider {
            height: 1px;
            background-color: #3a3a3a;
            margin: 4px 0;
        }

        /* Volume control */
        .volume-control {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 4px 0;
        }

        .volume-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .volume-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .volume-value {
            font-size: 10px;
            color: #e0e0e0;
            font-family: monospace;
        }

        .volume-slider {
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-track {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #2563eb;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -4px;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            background: #3b82f6;
        }

        .volume-slider::-moz-range-track {
            width: 100%;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #2563eb;
            border: none;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb:hover {
            background: #3b82f6;
        }

        /* Right sidebar */
        .right-sidebar {
            width: 140px;
            background-color: #222;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }

        /* File list panel */
        .file-list-panel {
            flex: 1;
            border-top: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .file-list-header {
            padding: 6px 8px;
            font-size: 10px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #3a3a3a;
        }

        .file-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
        }

        .file-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 6px;
            margin-bottom: 2px;
            background-color: #2a2a2a;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.15s;
        }

        .file-item:hover {
            background-color: #3a3a3a;
        }

        .file-item.active {
            background-color: #2563eb;
        }

        .file-name {
            flex: 1;
            font-size: 11px;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-delete {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 0;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            line-height: 1;
            transition: color 0.15s;
        }

        .file-delete:hover {
            color: #ef4444;
        }

        /* Drag and drop overlay */
        .drag-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(37, 99, 235, 0.2);
            border: 3px dashed #2563eb;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }

        .drag-overlay.visible {
            display: flex;
        }

        .drag-overlay-text {
            font-size: 24px;
            color: #2563eb;
            font-weight: 600;
        }

        /* FFT size selector */
        .fft-select {
            background-color: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Selection info overlay */
        .selection-info {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            display: none;
        }

        .selection-info.visible {
            display: block;
        }

        /* Status bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 6px 12px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            font-size: 12px;
            color: #888;
        }

        .status-bar .info {
            display: flex;
            gap: 16px;
        }

        /* Modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            display: none;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
        }

        .modal h3 {
            margin-bottom: 16px;
            font-weight: 500;
        }

        .modal-row {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            gap: 12px;
        }

        .modal-row label {
            flex: 0 0 100px;
            font-size: 13px;
        }

        .modal-row select,
        .modal-row input {
            flex: 1;
            background-color: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 20px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 13px;
        }

        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .checkbox-label input[type="checkbox"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .checkbox-label input[type="checkbox"]:disabled + span {
            opacity: 0.5;
        }

        /* Hidden file input */
        #fileInput, #projectInput {
            display: none;
        }

        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            font-size: 11px;
            color: #666;
            margin-left: 8px;
        }

        /* Cue point lane */
        .cuepoint-container {
            height: 32px;
            position: relative;
            background-color: #252525;
            border-bottom: 1px solid #3a3a3a;
            overflow: hidden;
        }

        #cuepointCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Cue point name input modal */
        .cuepoint-input {
            position: absolute;
            background-color: #2a2a2a;
            border: 1px solid #4a4a4a;
            border-radius: 4px;
            padding: 4px 8px;
            display: none;
            z-index: 50;
        }

        .cuepoint-input.visible {
            display: block;
        }

        .cuepoint-input input {
            background-color: #1a1a1a;
            border: 1px solid #4a4a4a;
            color: #e0e0e0;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            width: 120px;
        }

        .cuepoint-input input:focus {
            outline: none;
            border-color: #2563eb;
        }
    </style>
</head>
<body>
    <input type="file" id="fileInput" accept=".wav,.aif,.aiff" multiple>
    <input type="file" id="projectInput" accept=".seproj">

    <!-- Toolbar -->
    <div class="toolbar">
        <div class="toolbar-group">
            <span class="toolbar-label">File</span>
            <button id="importBtn">Import</button>
            <button id="exportBtn" disabled>Export</button>
            <button id="saveProjectBtn" disabled>Save</button>
            <button id="loadProjectBtn">Load</button>
            <button id="addCueBtn" disabled title="Add cue point at playhead (M)">+ Cue</button>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Transport</span>
            <button id="playBtn" class="transport" disabled title="Play (Space)">&#9654;</button>
            <button id="pauseBtn" class="transport" disabled title="Pause (Space)">&#10074;&#10074;</button>
            <button id="stopBtn" class="transport" disabled title="Stop">&#9632;</button>
            <button id="loopBtn" class="transport" disabled title="Loop Selection (L)">&#8635;</button>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Zoom</span>
            <button id="zoomInBtn" disabled title="Zoom In (+)">+</button>
            <button id="zoomOutBtn" disabled title="Zoom Out (-)">-</button>
            <button id="zoomFitBtn" disabled title="Fit to Window">Fit</button>
        </div>
        <div class="toolbar-group">
            <span class="toolbar-label">Edit</span>
            <button id="undoBtn" disabled title="Undo (⌘Z)">Undo</button>
            <button id="redoBtn" disabled title="Redo (⌘⇧Z)">Redo</button>
            <button id="trimBtn" disabled title="Trim to selection (⌘T)">Trim</button>
            <button id="gainBtn" disabled title="Apply Gain">Gain</button>
            <button id="normalizeBtn" disabled title="Normalize (⌘⇧N)">Normalize</button>
            <button id="fadeInBtn" disabled title="Fade In (⌘F)">Fade In</button>
            <button id="fadeOutBtn" disabled title="Fade Out (⌘⇧F)">Fade Out</button>
            <button id="reverseBtn" disabled title="Reverse">Reverse</button>
        </div>
    </div>

    <!-- Main content area -->
    <div class="main-content">
        <!-- Editor area -->
        <div class="editor-area">
            <!-- Cue point lane -->
            <div class="cuepoint-container">
                <canvas id="cuepointCanvas"></canvas>
                <div class="cuepoint-input" id="cuepointInput">
                    <input type="text" id="cuepointNameInput" placeholder="Cue name...">
                </div>
            </div>
            <!-- Waveform -->
            <div class="waveform-container">
                <canvas id="waveformCanvas"></canvas>
                <div class="selection-info" id="selectionInfo"></div>
                <div class="drag-overlay" id="dragOverlay">
                    <div class="drag-overlay-text">Drop audio files here</div>
                </div>
            </div>
            <!-- Spectrogram -->
            <div class="spectrogram-container">
                <canvas id="spectrogramCanvas"></canvas>
                <span class="spectrogram-label">Spectrum</span>
                <div class="spectrogram-fft">
                    <span class="spectrogram-fft-label">FFT:</span>
                    <select id="fftSize" class="fft-select">
                        <option value="256">256</option>
                        <option value="512">512</option>
                        <option value="1024">1024</option>
                        <option value="2048" selected>2048</option>
                        <option value="4096">4096</option>
                        <option value="8192">8192</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Right sidebar -->
        <div class="right-sidebar">
            <!-- Meters panel -->
            <div class="meters-panel">
                <!-- Real-time Peak Meter -->
                <div class="meter">
                    <span class="meter-label">Peak (RT)</span>
                    <span class="meter-value" id="peakValue">-∞</span>
                    <span class="meter-unit">dBFS</span>
                    <div class="meter-bar-container">
                        <div class="meter-bar" id="peakBar" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stats-divider"></div>

                <!-- Volume Control -->
                <div class="volume-control">
                    <div class="volume-header">
                        <span class="volume-label">Output Volume</span>
                        <span class="volume-value" id="volumeValue">0 dB</span>
                    </div>
                    <input type="range" id="volumeSlider" class="volume-slider" min="-60" max="6" step="0.5" value="0">
                </div>

                <div class="stats-divider"></div>

                <!-- File Statistics -->
                <div class="file-stat">
                    <span class="file-stat-label">RMS Peak:</span>
                    <span class="file-stat-value" id="rmsPeakValue">-</span>
                </div>
                <div class="file-stat">
                    <span class="file-stat-label">True Peak:</span>
                    <span class="file-stat-value" id="truePeakValue">-</span>
                </div>
                <div class="file-stat">
                    <span class="file-stat-label">LUFS (file):</span>
                    <span class="file-stat-value" id="lufsValue">-</span>
                </div>

                <div class="stats-divider"></div>

                <!-- Real-time LUFS -->
                <div class="file-stat">
                    <span class="file-stat-label">LUFS (integrated):</span>
                    <span class="file-stat-value" id="lufsIntegrated">-</span>
                </div>
                <div class="file-stat">
                    <span class="file-stat-label">LUFS (short-term):</span>
                    <span class="file-stat-value" id="lufsShortTerm">-</span>
                </div>
                <div class="file-stat">
                    <span class="file-stat-label">LUFS (momentary):</span>
                    <span class="file-stat-value" id="lufsMomentary">-</span>
                </div>
            </div>

            <!-- File list panel -->
            <div class="file-list-panel">
                <div class="file-list-header">Files</div>
                <div class="file-list" id="fileList"></div>
            </div>
        </div>
    </div>

    <!-- Status bar -->
    <div class="status-bar">
        <div class="info">
            <span id="fileInfo">No file loaded</span>
            <span id="positionInfo"></span>
        </div>
        <span id="zoomInfo"></span>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <h3>Export Audio</h3>
            <div class="modal-row">
                <label>Format</label>
                <select id="exportFormat">
                    <option value="wav">WAV</option>
                    <option value="aif">AIF</option>
                </select>
            </div>
            <div class="modal-row">
                <label>Bit Depth</label>
                <select id="exportBitDepth">
                    <option value="16">16-bit</option>
                    <option value="24">24-bit</option>
                    <option value="32">32-bit float</option>
                </select>
            </div>
            <div class="modal-row">
                <label>Dither</label>
                <select id="exportDither">
                    <option value="none" selected>None</option>
                    <option value="tpdf">TPDF</option>
                    <option value="shaped">Noise shaped</option>
                </select>
            </div>
            <div class="modal-row">
                <label></label>
                <label class="checkbox-label">
                    <input type="checkbox" id="exportSelection" disabled>
                    <span>Export selection only</span>
                </label>
            </div>
            <div class="modal-buttons">
                <button id="exportCancelBtn">Cancel</button>
                <button id="exportConfirmBtn" class="primary">Export</button>
            </div>
        </div>
    </div>

    <!-- Normalize Modal -->
    <div class="modal-overlay" id="normalizeModal">
        <div class="modal">
            <h3>Normalize</h3>
            <div class="modal-row">
                <label>Peak Level (dBFS)</label>
                <input type="number" id="normalizeLevel" value="0" min="-60" max="0" step="0.1">
            </div>
            <div class="modal-buttons">
                <button id="normalizeCancelBtn">Cancel</button>
                <button id="normalizeConfirmBtn" class="primary">Apply</button>
            </div>
        </div>
    </div>

    <!-- Gain Modal -->
    <div class="modal-overlay" id="gainModal">
        <div class="modal">
            <h3>Apply Gain</h3>
            <div class="modal-row">
                <label>Gain (dB)</label>
                <input type="number" id="gainAmount" value="0" min="-60" max="60" step="0.1">
            </div>
            <div class="modal-buttons">
                <button id="gainCancelBtn">Cancel</button>
                <button id="gainConfirmBtn" class="primary">Apply</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== Audio Engine ====================
        class AudioEngine {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.sourceNode = null;
                this.analyserNode = null;
                this.gainNode = null;
                this.isPlaying = false;
                this.isPaused = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.onPlaybackEnd = null;
                this.onPositionUpdate = null;
                this.animationFrame = null;
                this.fftSize = 2048;
                this.looping = false;
                this.loopStart = 0;
                this.loopEnd = 0;
            }

            async init() {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                if (!this.gainNode) {
                    this.gainNode = this.audioContext.createGain();
                    this.gainNode.gain.value = 1.0; // 0 dB default
                }
                if (!this.analyserNode) {
                    this.analyserNode = this.audioContext.createAnalyser();
                    this.analyserNode.fftSize = this.fftSize;
                    this.analyserNode.smoothingTimeConstant = 0.8;
                    // Chain: source -> gainNode -> analyserNode -> destination
                    this.gainNode.connect(this.analyserNode);
                    this.analyserNode.connect(this.audioContext.destination);
                }
            }

            setVolume(db) {
                if (!this.gainNode) return;
                // Convert dB to linear gain
                const gain = Math.pow(10, db / 20);
                this.gainNode.gain.value = gain;
            }

            getVolume() {
                if (!this.gainNode) return 0;
                // Convert linear gain to dB
                return 20 * Math.log10(this.gainNode.gain.value);
            }

            setFFTSize(size) {
                this.fftSize = size;
                if (this.analyserNode) {
                    this.analyserNode.fftSize = size;
                }
            }

            getAnalyserNode() {
                return this.analyserNode;
            }

            async loadAudio(arrayBuffer) {
                await this.init();
                this.stop();
                this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                return this.audioBuffer;
            }

            play(startOffset = 0) {
                if (!this.audioBuffer) return;

                this.stopPlayback();
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = this.audioBuffer;
                this.sourceNode.connect(this.gainNode);

                this.sourceNode.onended = () => {
                    if (this.isPlaying && !this.isPaused) {
                        this.stop();
                        if (this.onPlaybackEnd) this.onPlaybackEnd();
                    }
                };

                this.sourceNode.start(0, startOffset);
                this.startTime = this.audioContext.currentTime - startOffset;
                this.isPlaying = true;
                this.isPaused = false;

                this.updatePosition();
            }

            playSelection(startTime, endTime) {
                if (!this.audioBuffer) return;

                this.stopPlayback();
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = this.audioBuffer;
                this.sourceNode.connect(this.gainNode);

                // Store loop points
                this.loopStart = startTime;
                this.loopEnd = endTime;

                this.sourceNode.onended = () => {
                    if (this.isPlaying && !this.isPaused) {
                        if (this.looping && this.loopEnd > this.loopStart) {
                            // Loop: restart from beginning of selection
                            this.playSelection(this.loopStart, this.loopEnd);
                        } else {
                            this.stop();
                            if (this.onPlaybackEnd) this.onPlaybackEnd();
                        }
                    }
                };

                const duration = endTime - startTime;
                this.sourceNode.start(0, startTime, duration);
                this.startTime = this.audioContext.currentTime - startTime;
                this.isPlaying = true;
                this.isPaused = false;

                this.updatePosition();
            }

            setLooping(enabled) {
                this.looping = enabled;
            }

            isLooping() {
                return this.looping;
            }

            resume() {
                if (!this.isPaused) return;
                this.play(this.pauseTime);
            }

            stopPlayback() {
                if (this.sourceNode) {
                    try {
                        this.sourceNode.stop();
                    } catch (e) {}
                    this.sourceNode.disconnect();
                    this.sourceNode = null;
                }
                cancelAnimationFrame(this.animationFrame);
            }

            pause() {
                if (!this.isPlaying || this.isPaused) return;
                this.pauseTime = this.getCurrentTime();
                this.sourceNode.stop();
                this.isPaused = true;
                this.isPlaying = false;
                cancelAnimationFrame(this.animationFrame);
            }

            stop() {
                this.stopPlayback();
                this.isPlaying = false;
                this.isPaused = false;
                this.pauseTime = 0;
            }

            getCurrentTime() {
                if (this.isPaused) return this.pauseTime;
                if (!this.isPlaying) return 0;
                return this.audioContext.currentTime - this.startTime;
            }

            getDuration() {
                return this.audioBuffer ? this.audioBuffer.duration : 0;
            }

            updatePosition() {
                if (!this.isPlaying) return;
                if (this.onPositionUpdate) {
                    this.onPositionUpdate(this.getCurrentTime());
                }
                this.animationFrame = requestAnimationFrame(() => this.updatePosition());
            }

            setBuffer(buffer) {
                this.stop();
                this.audioBuffer = buffer;
            }
        }

        // ==================== Waveform Renderer ====================
        class WaveformRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.audioBuffer = null;
                this.samplesPerPixel = 100;
                this.scrollOffset = 0;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.playheadPosition = 0;
                this.peaks = null;
                this.isDragging = false;
                this.dragStart = 0;

                this.setupResize();
                this.setupInteraction();
            }

            setupResize() {
                const resizeObserver = new ResizeObserver(() => this.resize());
                resizeObserver.observe(this.canvas.parentElement);
                this.resize();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                this.render();
            }

            setupInteraction() {
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
            }

            onDoubleClick(e) {
                if (!this.audioBuffer) return;
                this.selectAll();
            }

            selectAll() {
                if (!this.audioBuffer) return;
                this.selectionStart = 0;
                this.selectionEnd = this.audioBuffer.length;
                this.playheadPosition = 0;
                this.render();
                this.updateSelectionInfo();
                if (this.onPlayheadChange) this.onPlayheadChange(0);
                if (this.onSelectionUpdate) this.onSelectionUpdate(0, this.audioBuffer.length);
                if (this.onSelectionChange) this.onSelectionChange();
            }

            onMouseDown(e) {
                if (!this.audioBuffer) return;
                this.isDragging = true;
                this.dragStartX = e.offsetX;
                this.dragStartSample = this.pixelToSample(e.offsetX);
                this.hasDragged = false;

                // Immediately move playhead to click position
                this.playheadPosition = this.dragStartSample;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.render();
                if (this.onPlayheadChange) this.onPlayheadChange(this.playheadPosition);
                if (this.onSelectionUpdate) this.onSelectionUpdate(null, null);
            }

            onMouseMove(e) {
                if (!this.isDragging || !this.audioBuffer) return;
                const x = e.offsetX;
                const dragDistance = Math.abs(x - this.dragStartX);

                // Only start selection if dragged more than 5 pixels
                if (dragDistance > 5) {
                    this.hasDragged = true;
                    this.selectionStart = this.dragStartSample;
                    this.selectionEnd = this.pixelToSample(x);
                    this.render();
                    this.updateSelectionInfo();
                    if (this.onSelectionUpdate) this.onSelectionUpdate(this.selectionStart, this.selectionEnd);
                }
            }

            onMouseUp(e) {
                if (!this.isDragging) return;
                this.isDragging = false;

                if (this.hasDragged) {
                    // Normalize selection (start < end)
                    if (this.selectionStart !== null && this.selectionEnd !== null) {
                        if (this.selectionStart > this.selectionEnd) {
                            [this.selectionStart, this.selectionEnd] = [this.selectionEnd, this.selectionStart];
                        }
                        // Clear selection if too small
                        if (this.selectionEnd - this.selectionStart < 10) {
                            this.selectionStart = null;
                            this.selectionEnd = null;
                        }
                    }
                    this.render();
                    this.updateSelectionInfo();
                    if (this.onSelectionUpdate) this.onSelectionUpdate(this.selectionStart, this.selectionEnd);
                    if (this.onSelectionChange) this.onSelectionChange();
                } else {
                    // It was a click, not a drag - playhead already moved in onMouseDown
                    if (this.onSelectionChange) this.onSelectionChange();
                }
            }

            onWheel(e) {
                if (!this.audioBuffer) return;
                e.preventDefault();

                const hasHorizontalScroll = Math.abs(e.deltaX) > Math.abs(e.deltaY) * 0.5;

                if (hasHorizontalScroll) {
                    // Horizontal scroll (trackpad left/right)
                    const scrollAmount = e.deltaX * this.samplesPerPixel * 0.5;
                    this.scrollOffset += scrollAmount;
                    this.clampScroll();
                    this.calculatePeaks();
                    this.render();
                    if (this.onScrollChange) this.onScrollChange();
                } else if (Math.abs(e.deltaY) > 0) {
                    // Vertical scroll = zoom (trackpad up/down)
                    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
                    const mouseX = e.offsetX;
                    const sampleAtMouse = this.pixelToSample(mouseX);

                    this.samplesPerPixel = Math.max(1, Math.min(
                        this.audioBuffer.length / 100,
                        this.samplesPerPixel * zoomFactor
                    ));

                    // Adjust scroll to keep sample under mouse
                    this.scrollOffset = sampleAtMouse - mouseX * this.samplesPerPixel;
                    this.clampScroll();
                    this.calculatePeaks();
                    this.render();
                    if (this.onZoomChange) this.onZoomChange();
                }
            }

            setAudioBuffer(buffer) {
                this.audioBuffer = buffer;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.scrollOffset = 0;
                this.playheadPosition = 0;
                if (this.onSelectionUpdate) this.onSelectionUpdate(null, null);
                this.zoomFit();
            }

            zoomFit() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = this.audioBuffer.length / this.width;
                this.scrollOffset = 0;
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            zoomIn() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = Math.max(1, this.samplesPerPixel * 0.5);
                this.clampScroll();
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            zoomOut() {
                if (!this.audioBuffer) return;
                this.samplesPerPixel = Math.min(
                    this.audioBuffer.length / 100,
                    this.samplesPerPixel * 2
                );
                this.clampScroll();
                this.calculatePeaks();
                this.render();
                if (this.onZoomChange) this.onZoomChange();
            }

            clampScroll() {
                const maxScroll = Math.max(0, this.audioBuffer.length - this.width * this.samplesPerPixel);
                this.scrollOffset = Math.max(0, Math.min(maxScroll, this.scrollOffset));
            }

            pixelToSample(x) {
                return Math.floor(this.scrollOffset + x * this.samplesPerPixel);
            }

            sampleToPixel(sample) {
                return (sample - this.scrollOffset) / this.samplesPerPixel;
            }

            calculatePeaks() {
                if (!this.audioBuffer) return;

                const channelData = this.audioBuffer.getChannelData(0);
                const numPeaks = Math.ceil(this.width);
                this.peaks = new Float32Array(numPeaks * 2);

                for (let i = 0; i < numPeaks; i++) {
                    const startSample = Math.floor(this.scrollOffset + i * this.samplesPerPixel);
                    const endSample = Math.floor(startSample + this.samplesPerPixel);

                    let min = 0, max = 0;
                    for (let j = startSample; j < endSample && j < channelData.length; j++) {
                        if (j >= 0) {
                            const value = channelData[j];
                            if (value < min) min = value;
                            if (value > max) max = value;
                        }
                    }
                    this.peaks[i * 2] = min;
                    this.peaks[i * 2 + 1] = max;
                }
            }

            setPlayheadPosition(time) {
                if (!this.audioBuffer) return;
                const sample = Math.floor(time * this.audioBuffer.sampleRate);
                this.playheadPosition = sample;
                this.render();
            }

            getSelection() {
                if (this.selectionStart === null || this.selectionEnd === null) return null;
                return {
                    start: Math.min(this.selectionStart, this.selectionEnd),
                    end: Math.max(this.selectionStart, this.selectionEnd)
                };
            }

            hasSelection() {
                return this.selectionStart !== null && this.selectionEnd !== null;
            }

            updateSelectionInfo() {
                const info = document.getElementById('selectionInfo');
                const selection = this.getSelection();
                if (!selection || !this.audioBuffer) {
                    info.classList.remove('visible');
                    return;
                }

                const startTime = selection.start / this.audioBuffer.sampleRate;
                const endTime = selection.end / this.audioBuffer.sampleRate;
                const duration = endTime - startTime;

                info.textContent = `Selection: ${formatTime(startTime)} - ${formatTime(endTime)} (${formatTime(duration)})`;
                info.classList.add('visible');
            }

            render() {
                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;

                // Clear
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);

                if (!this.audioBuffer || !this.peaks) {
                    // Draw placeholder text
                    ctx.fillStyle = '#444';
                    ctx.font = '16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Import an audio file to begin', width / 2, height / 2);
                    return;
                }

                const centerY = height / 2;
                const amplitude = height / 2 - 10;

                // Draw selection
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    const startX = this.sampleToPixel(Math.min(this.selectionStart, this.selectionEnd));
                    const endX = this.sampleToPixel(Math.max(this.selectionStart, this.selectionEnd));
                    ctx.fillStyle = 'rgba(37, 99, 235, 0.3)';
                    ctx.fillRect(startX, 0, endX - startX, height);
                }

                // Draw center line
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(width, centerY);
                ctx.stroke();

                // Draw waveform
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < this.peaks.length / 2; i++) {
                    const min = this.peaks[i * 2];
                    const max = this.peaks[i * 2 + 1];
                    const y1 = centerY - max * amplitude;
                    const y2 = centerY - min * amplitude;
                    ctx.fillRect(i, y1, 1, Math.max(1, y2 - y1));
                }

                // Draw file end indicator
                const fileEndX = this.sampleToPixel(this.audioBuffer.length);
                if (fileEndX >= 0 && fileEndX <= width) {
                    // Draw dashed vertical line at file end
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(fileEndX, 0);
                    ctx.lineTo(fileEndX, height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // Shade area beyond file end
                if (fileEndX < width && fileEndX >= 0) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(fileEndX, 0, width - fileEndX, height);
                }

                // Draw playhead
                const playheadX = this.sampleToPixel(this.playheadPosition);
                if (playheadX >= 0 && playheadX <= width) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                }
            }
        }

        // ==================== Spectrogram Renderer ====================
        class SpectrogramRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.audioBuffer = null;
                this.fftSize = 2048;
                this.analyserNode = null;
                this.isRealtime = false;
                this.animationFrame = null;
                this.scrollOffset = 0;
                this.samplesPerPixel = 100;
                this.playheadPosition = 0;
                this.selectionStart = null;
                this.selectionEnd = null;
                this.smoothedSpectrum = null;

                this.setupResize();
            }

            setupResize() {
                const resizeObserver = new ResizeObserver(() => this.resize());
                resizeObserver.observe(this.canvas.parentElement);
                this.resize();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                this.render();
            }

            setAudioBuffer(buffer) {
                this.audioBuffer = buffer;
                this.smoothedSpectrum = null;
                this.render();
            }

            setAnalyserNode(node) {
                this.analyserNode = node;
            }

            setFFTSize(size) {
                this.fftSize = size;
                this.smoothedSpectrum = null;
            }

            setScrollOffset(offset) {
                this.scrollOffset = offset;
                if (!this.isRealtime) this.render();
            }

            setSamplesPerPixel(spp) {
                this.samplesPerPixel = spp;
                if (!this.isRealtime) this.render();
            }

            setPlayheadPosition(sample) {
                this.playheadPosition = sample;
                if (!this.isRealtime) this.render();
            }

            setSelection(start, end) {
                this.selectionStart = start;
                this.selectionEnd = end;
                if (!this.isRealtime) this.render();
            }

            sampleToPixel(sample) {
                return (sample - this.scrollOffset) / this.samplesPerPixel;
            }

            startRealtime() {
                this.isRealtime = true;
                this.smoothedSpectrum = null;
                this.renderRealtime();
            }

            stopRealtime() {
                this.isRealtime = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                this.smoothedSpectrum = null;
                this.render();
            }

            renderRealtime() {
                if (!this.isRealtime || !this.analyserNode) return;

                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;
                const frequencyData = new Uint8Array(this.analyserNode.frequencyBinCount);
                this.analyserNode.getByteFrequencyData(frequencyData);

                // Clear with dark background
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, width, height);

                // Smooth the spectrum data
                const numBins = 128; // Reduce to fewer bins for smoother display
                const binnedData = new Float32Array(numBins);
                const binSize = Math.floor(frequencyData.length / numBins);

                for (let i = 0; i < numBins; i++) {
                    let sum = 0;
                    const start = i * binSize;
                    for (let j = 0; j < binSize; j++) {
                        sum += frequencyData[start + j];
                    }
                    binnedData[i] = sum / binSize / 255;
                }

                // Apply smoothing over time
                if (!this.smoothedSpectrum || this.smoothedSpectrum.length !== numBins) {
                    this.smoothedSpectrum = new Float32Array(binnedData);
                } else {
                    const smoothing = 0.7;
                    for (let i = 0; i < numBins; i++) {
                        this.smoothedSpectrum[i] = this.smoothedSpectrum[i] * smoothing + binnedData[i] * (1 - smoothing);
                    }
                }

                // Create gradient for fill
                const gradient = ctx.createLinearGradient(0, height, 0, 0);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.1)');
                gradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.4)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.8)');

                // Draw smooth filled curve
                ctx.beginPath();
                ctx.moveTo(0, height);

                for (let i = 0; i < numBins; i++) {
                    // Logarithmic frequency scale
                    const logPos = Math.log10(1 + i * 9 / numBins) / Math.log10(10);
                    const x = logPos * width;
                    const barHeight = this.smoothedSpectrum[i] * height * 0.9;

                    if (i === 0) {
                        ctx.lineTo(x, height - barHeight);
                    } else {
                        // Use quadratic curves for smoothness
                        const prevLogPos = Math.log10(1 + (i - 1) * 9 / numBins) / Math.log10(10);
                        const prevX = prevLogPos * width;
                        const cpX = (prevX + x) / 2;
                        const prevHeight = this.smoothedSpectrum[i - 1] * height * 0.9;
                        ctx.quadraticCurveTo(prevX, height - prevHeight, cpX, height - (prevHeight + barHeight) / 2);
                    }
                }

                ctx.lineTo(width, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw the line on top
                ctx.beginPath();
                for (let i = 0; i < numBins; i++) {
                    const logPos = Math.log10(1 + i * 9 / numBins) / Math.log10(10);
                    const x = logPos * width;
                    const barHeight = this.smoothedSpectrum[i] * height * 0.9;

                    if (i === 0) {
                        ctx.moveTo(x, height - barHeight);
                    } else {
                        const prevLogPos = Math.log10(1 + (i - 1) * 9 / numBins) / Math.log10(10);
                        const prevX = prevLogPos * width;
                        const cpX = (prevX + x) / 2;
                        const prevHeight = this.smoothedSpectrum[i - 1] * height * 0.9;
                        ctx.quadraticCurveTo(prevX, height - prevHeight, cpX, height - (prevHeight + barHeight) / 2);
                    }
                }
                ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw glow effect
                ctx.shadowColor = '#3b82f6';
                ctx.shadowBlur = 10;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Draw frequency labels
                this.drawFrequencyLabels(ctx, width, height);

                this.animationFrame = requestAnimationFrame(() => this.renderRealtime());
            }

            render() {
                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;

                // Clear with dark background
                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, width, height);

                // Draw selection highlight
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    const startX = this.sampleToPixel(Math.min(this.selectionStart, this.selectionEnd));
                    const endX = this.sampleToPixel(Math.max(this.selectionStart, this.selectionEnd));
                    ctx.fillStyle = 'rgba(37, 99, 235, 0.2)';
                    ctx.fillRect(startX, 0, endX - startX, height);
                }

                if (!this.audioBuffer) {
                    ctx.fillStyle = '#444';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Load audio to view spectrum', width / 2, height / 2);
                    return;
                }

                // Compute spectrum at playhead position
                const sampleRate = this.audioBuffer.sampleRate;
                const channelData = this.audioBuffer.getChannelData(0);
                const startSample = Math.max(0, this.playheadPosition - this.fftSize / 2);

                // Extract samples for FFT
                const samples = new Float32Array(this.fftSize);
                for (let i = 0; i < this.fftSize; i++) {
                    const idx = startSample + i;
                    if (idx < channelData.length && idx >= 0) {
                        // Apply Hann window
                        const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / this.fftSize));
                        samples[i] = channelData[idx] * window;
                    }
                }

                // Compute FFT
                const spectrum = this.computeFFT(samples);
                const nyquist = sampleRate / 2;

                // Bin the spectrum for smoother display
                const numBins = 128;
                const binnedData = new Float32Array(numBins);

                for (let i = 0; i < numBins; i++) {
                    // Map bin to frequency using log scale
                    const freqRatio = Math.pow(10, i / numBins) / 10;
                    const binIndex = Math.floor(freqRatio * spectrum.length);
                    const nextBinIndex = Math.floor(Math.pow(10, (i + 1) / numBins) / 10 * spectrum.length);

                    let sum = 0;
                    let count = 0;
                    for (let j = binIndex; j < nextBinIndex && j < spectrum.length; j++) {
                        sum += spectrum[j];
                        count++;
                    }
                    if (count > 0) {
                        const magnitude = sum / count;
                        const db = 20 * Math.log10(magnitude + 1e-10);
                        binnedData[i] = Math.max(0, Math.min(1, (db + 80) / 70));
                    }
                }

                // Create gradient for fill
                const gradient = ctx.createLinearGradient(0, height, 0, 0);
                gradient.addColorStop(0, 'rgba(59, 130, 246, 0.05)');
                gradient.addColorStop(0.3, 'rgba(59, 130, 246, 0.3)');
                gradient.addColorStop(0.7, 'rgba(59, 130, 246, 0.5)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.7)');

                // Draw smooth filled curve
                ctx.beginPath();
                ctx.moveTo(0, height);

                const points = [];
                for (let i = 0; i < numBins; i++) {
                    const logPos = Math.log10(1 + i * 9 / numBins) / Math.log10(10);
                    const x = logPos * width;
                    const y = height - binnedData[i] * height * 0.85;
                    points.push({ x, y });
                }

                // Draw using bezier curves for extra smoothness
                ctx.moveTo(0, height);
                ctx.lineTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }

                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                ctx.lineTo(width, height);
                ctx.closePath();
                ctx.fillStyle = gradient;
                ctx.fill();

                // Draw the smooth line on top
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);

                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }

                ctx.lineTo(points[points.length - 1].x, points[points.length - 1].y);

                // Gradient stroke
                const strokeGradient = ctx.createLinearGradient(0, height, 0, 0);
                strokeGradient.addColorStop(0, '#3b82f6');
                strokeGradient.addColorStop(0.5, '#3b82f6');
                strokeGradient.addColorStop(1, '#3b82f6');

                ctx.strokeStyle = strokeGradient;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Add subtle glow
                ctx.shadowColor = '#6366f1';
                ctx.shadowBlur = 8;
                ctx.stroke();
                ctx.shadowBlur = 0;

                // Draw frequency labels
                this.drawFrequencyLabels(ctx, width, height);

                // Draw playhead
                const playheadX = this.sampleToPixel(this.playheadPosition);
                if (playheadX >= 0 && playheadX <= width) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                }

                // Draw selection boundaries
                if (this.selectionStart !== null && this.selectionEnd !== null) {
                    const startX = this.sampleToPixel(Math.min(this.selectionStart, this.selectionEnd));
                    const endX = this.sampleToPixel(Math.max(this.selectionStart, this.selectionEnd));

                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)';
                    ctx.lineWidth = 1;

                    if (startX >= 0 && startX <= width) {
                        ctx.beginPath();
                        ctx.moveTo(startX, 0);
                        ctx.lineTo(startX, height);
                        ctx.stroke();
                    }

                    if (endX >= 0 && endX <= width) {
                        ctx.beginPath();
                        ctx.moveTo(endX, 0);
                        ctx.lineTo(endX, height);
                        ctx.stroke();
                    }
                }
            }

            drawFrequencyLabels(ctx, width, height) {
                ctx.fillStyle = '#666';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'left';
                const sampleRate = this.audioBuffer ? this.audioBuffer.sampleRate : 44100;
                const nyquist = sampleRate / 2;
                const freqs = [100, 500, 1000, 2000, 5000, 10000, 20000].filter(f => f < nyquist);

                freqs.forEach(freq => {
                    const logPos = Math.log10(1 + (freq / nyquist) * 9) / Math.log10(10);
                    const x = logPos * width;
                    const label = freq >= 1000 ? `${freq/1000}k` : freq.toString();
                    ctx.fillText(label, x + 2, height - 3);

                    // Draw subtle grid line
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height - 12);
                    ctx.stroke();
                });
            }

            computeFFT(samples) {
                const n = samples.length;
                const spectrum = new Float32Array(n / 2);

                // Simple DFT - not optimal but works for visualization
                for (let k = 0; k < n / 2; k++) {
                    let real = 0, imag = 0;
                    for (let t = 0; t < n; t++) {
                        const angle = 2 * Math.PI * k * t / n;
                        real += samples[t] * Math.cos(angle);
                        imag -= samples[t] * Math.sin(angle);
                    }
                    spectrum[k] = Math.sqrt(real * real + imag * imag) / n;
                }

                return spectrum;
            }
        }

        // ==================== Metering ====================
        class Metering {
            constructor() {
                // Real-time peak meter
                this.peakValue = document.getElementById('peakValue');
                this.peakBar = document.getElementById('peakBar');

                // File statistics (non-realtime)
                this.rmsPeakValue = document.getElementById('rmsPeakValue');
                this.truePeakValue = document.getElementById('truePeakValue');
                this.lufsValue = document.getElementById('lufsValue');

                // Real-time LUFS displays
                this.lufsIntegratedEl = document.getElementById('lufsIntegrated');
                this.lufsShortTermEl = document.getElementById('lufsShortTerm');
                this.lufsMomentaryEl = document.getElementById('lufsMomentary');

                this.analyserNode = null;
                this.audioBuffer = null;
                this.isRealtime = false;
                this.animationFrame = null;

                // File-wide statistics
                this.fileStats = {
                    rmsPeak: null,
                    truePeak: null,
                    lufs: null
                };

                // Real-time LUFS state
                this.lufsState = {
                    kWeightedChannels: null,   // Pre-filtered K-weighted audio data
                    sampleRate: 0,
                    blockSize: 0,              // 400ms in samples
                    integratedBlocks: [],      // All blocks since play started (for gating)
                    shortTermBlocks: [],       // Last 3 seconds of blocks
                    currentSample: 0,          // Current playback position
                    lastBlockSample: 0         // Last sample where we calculated a block
                };
            }

            setAnalyserNode(node) {
                this.analyserNode = node;
            }

            setAudioBuffer(buffer) {
                this.audioBuffer = buffer;
                if (buffer) {
                    this.calculateFileStats(buffer);
                    this.prepareRealtimeLUFS(buffer);
                } else {
                    this.reset();
                }
            }

            prepareRealtimeLUFS(audioBuffer) {
                // Pre-compute K-weighted audio for real-time LUFS measurement
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const coeffs = this.getKWeightingCoeffs(sampleRate);

                this.lufsState.kWeightedChannels = [];
                this.lufsState.sampleRate = sampleRate;
                this.lufsState.blockSize = Math.floor(sampleRate * 0.4); // 400ms

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    const afterShelf = this.applyBiquad(data, coeffs.shelf);
                    const kWeighted = this.applyBiquad(afterShelf, coeffs.highpass);
                    this.lufsState.kWeightedChannels.push(kWeighted);
                }
            }

            calculateFileStats(audioBuffer) {
                const numChannels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;

                // Calculate RMS Peak (max RMS in 300ms windows)
                const windowSize = Math.floor(sampleRate * 0.3); // 300ms window
                let rmsPeakLinear = 0;
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < length - windowSize; i += Math.floor(windowSize / 4)) {
                        let sum = 0;
                        for (let j = 0; j < windowSize; j++) {
                            sum += data[i + j] * data[i + j];
                        }
                        const rms = Math.sqrt(sum / windowSize);
                        if (rms > rmsPeakLinear) rmsPeakLinear = rms;
                    }
                }
                const rmsPeak = rmsPeakLinear > 0 ? 20 * Math.log10(rmsPeakLinear) : -Infinity;

                // Calculate True Peak using 4x oversampling with sinc interpolation
                let truePeakLinear = 0;
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < length; i++) {
                        // Check actual sample
                        const abs = Math.abs(data[i]);
                        if (abs > truePeakLinear) truePeakLinear = abs;
                    }
                    // 4x oversampling with 4-point sinc interpolation
                    for (let i = 1; i < length - 2; i++) {
                        for (let phase = 1; phase <= 3; phase++) {
                            const t = phase / 4;
                            // 4-point Lagrange/sinc approximation
                            const s0 = data[i - 1];
                            const s1 = data[i];
                            const s2 = data[i + 1];
                            const s3 = data[i + 2];
                            // Catmull-Rom spline interpolation (better than linear, approximates sinc)
                            const interSample = s1 + 0.5 * t * (s2 - s0 + t * (2 * s0 - 5 * s1 + 4 * s2 - s3 + t * (3 * (s1 - s2) + s3 - s0)));
                            const absInter = Math.abs(interSample);
                            if (absInter > truePeakLinear) truePeakLinear = absInter;
                        }
                    }
                }
                const truePeak = truePeakLinear > 0 ? 20 * Math.log10(truePeakLinear) : -Infinity;

                // Calculate LUFS (ITU-R BS.1770-4 integrated loudness)
                const lufs = this.calculateLUFS(audioBuffer);

                this.fileStats = { rmsPeak, truePeak, lufs };
                this.updateFileStatsDisplay();
            }

            // K-weighting filter coefficients for common sample rates
            getKWeightingCoeffs(sampleRate) {
                // Pre-computed biquad coefficients for K-weighting
                // Stage 1: High shelf (+4dB at high frequencies)
                // Stage 2: High-pass (~38Hz)
                // These are approximate coefficients - exact values depend on sample rate

                if (sampleRate === 48000) {
                    return {
                        shelf: { b0: 1.53512485958697, b1: -2.69169618940638, b2: 1.19839281085285, a1: -1.69065929318241, a2: 0.73248077421585 },
                        highpass: { b0: 1.0, b1: -2.0, b2: 1.0, a1: -1.99004745483398, a2: 0.99007225036621 }
                    };
                } else if (sampleRate === 44100) {
                    return {
                        shelf: { b0: 1.53084094649361, b1: -2.65099526752845, b2: 1.16907762258337, a1: -1.66375011657313, a2: 0.71265879083903 },
                        highpass: { b0: 1.0, b1: -2.0, b2: 1.0, a1: -1.98916615635498, a2: 0.98919469658594 }
                    };
                } else {
                    // Generic approximation for other sample rates
                    const fc1 = 1500.0; // shelf frequency
                    const fc2 = 38.0;   // highpass frequency
                    const Q = 0.707;

                    // High shelf approximation
                    const K1 = Math.tan(Math.PI * fc1 / sampleRate);
                    const V = Math.pow(10, 4 / 20); // +4dB
                    const norm1 = 1 / (1 + Math.sqrt(2) * K1 + K1 * K1);
                    const shelf = {
                        b0: (1 + Math.sqrt(2 * V) * K1 + V * K1 * K1) * norm1,
                        b1: 2 * (V * K1 * K1 - 1) * norm1,
                        b2: (1 - Math.sqrt(2 * V) * K1 + V * K1 * K1) * norm1,
                        a1: 2 * (K1 * K1 - 1) * norm1,
                        a2: (1 - Math.sqrt(2) * K1 + K1 * K1) * norm1
                    };

                    // High-pass
                    const K2 = Math.tan(Math.PI * fc2 / sampleRate);
                    const norm2 = 1 / (1 + K2 / Q + K2 * K2);
                    const highpass = {
                        b0: norm2,
                        b1: -2 * norm2,
                        b2: norm2,
                        a1: 2 * (K2 * K2 - 1) * norm2,
                        a2: (1 - K2 / Q + K2 * K2) * norm2
                    };

                    return { shelf, highpass };
                }
            }

            applyBiquad(samples, coeffs) {
                const output = new Float32Array(samples.length);
                let x1 = 0, x2 = 0, y1 = 0, y2 = 0;

                for (let i = 0; i < samples.length; i++) {
                    const x0 = samples[i];
                    const y0 = coeffs.b0 * x0 + coeffs.b1 * x1 + coeffs.b2 * x2 - coeffs.a1 * y1 - coeffs.a2 * y2;
                    output[i] = y0;
                    x2 = x1; x1 = x0;
                    y2 = y1; y1 = y0;
                }

                return output;
            }

            calculateLUFS(audioBuffer) {
                // ITU-R BS.1770-4 Integrated Loudness with gating
                const numChannels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const sampleRate = audioBuffer.sampleRate;
                const coeffs = this.getKWeightingCoeffs(sampleRate);

                // Apply K-weighting to each channel
                const kWeightedChannels = [];
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    const afterShelf = this.applyBiquad(data, coeffs.shelf);
                    const kWeighted = this.applyBiquad(afterShelf, coeffs.highpass);
                    kWeightedChannels.push(kWeighted);
                }

                // Channel weights per ITU-R BS.1770
                // L, R, C = 1.0; LFE = 0; Ls, Rs = 1.41
                const getChannelWeight = (channel, totalChannels) => {
                    if (totalChannels <= 2) return 1.0; // Mono or stereo
                    if (channel === 3) return 0; // LFE (in 5.1 layout: L, R, C, LFE, Ls, Rs)
                    if (channel >= 4) return 1.41; // Surround channels
                    return 1.0; // Front channels
                };

                // Block-based measurement: 400ms blocks, 75% overlap (100ms hop)
                const blockSize = Math.floor(sampleRate * 0.4); // 400ms
                const hopSize = Math.floor(sampleRate * 0.1);   // 100ms overlap
                const blocks = [];

                for (let start = 0; start + blockSize <= length; start += hopSize) {
                    let blockSum = 0;

                    for (let c = 0; c < numChannels; c++) {
                        const weight = getChannelWeight(c, numChannels);
                        if (weight === 0) continue;

                        const kWeighted = kWeightedChannels[c];
                        let channelSum = 0;

                        for (let i = 0; i < blockSize; i++) {
                            const sample = kWeighted[start + i];
                            channelSum += sample * sample;
                        }

                        blockSum += weight * (channelSum / blockSize);
                    }

                    // Store mean square for this block
                    blocks.push(blockSum);
                }

                if (blocks.length === 0) return -Infinity;

                // Convert to LUFS for gating
                const blockLoudness = blocks.map(ms => ms > 0 ? -0.691 + 10 * Math.log10(ms) : -Infinity);

                // Step 1: Absolute gating at -70 LUFS
                const absoluteThreshold = -70;
                const absoluteGatedBlocks = blocks.filter((ms, i) => blockLoudness[i] > absoluteThreshold);

                if (absoluteGatedBlocks.length === 0) return -Infinity;

                // Calculate ungated loudness (after absolute gating)
                const absoluteGatedMean = absoluteGatedBlocks.reduce((a, b) => a + b, 0) / absoluteGatedBlocks.length;
                const ungatedLoudness = absoluteGatedMean > 0 ? -0.691 + 10 * Math.log10(absoluteGatedMean) : -Infinity;

                // Step 2: Relative gating at -10 LU below ungated loudness
                const relativeThreshold = ungatedLoudness - 10;
                const relativeGatedBlocks = blocks.filter((ms, i) => blockLoudness[i] > relativeThreshold);

                if (relativeGatedBlocks.length === 0) return -Infinity;

                // Calculate final integrated loudness
                const finalMean = relativeGatedBlocks.reduce((a, b) => a + b, 0) / relativeGatedBlocks.length;

                if (finalMean > 0) {
                    return -0.691 + 10 * Math.log10(finalMean);
                }
                return -Infinity;
            }

            updateFileStatsDisplay() {
                const { rmsPeak, truePeak, lufs } = this.fileStats;

                this.rmsPeakValue.textContent = isFinite(rmsPeak) ? rmsPeak.toFixed(1) + ' dB' : '-';
                this.truePeakValue.textContent = isFinite(truePeak) ? truePeak.toFixed(1) + ' dB' : '-';
                this.lufsValue.textContent = isFinite(lufs) ? lufs.toFixed(1) + ' LUFS' : '-';
            }

            startRealtime() {
                this.isRealtime = true;
                // Reset LUFS state for new playback session
                this.lufsState.integratedBlocks = [];
                this.lufsState.shortTermBlocks = [];
                this.lufsState.currentSample = 0;
                this.lufsState.lastBlockSample = 0;
                this.updateRealtime();
            }

            stopRealtime() {
                this.isRealtime = false;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                // Reset peak display
                this.updatePeakDisplay(-Infinity);
                // Reset momentary (no longer valid), but keep integrated and short-term
                this.lufsMomentaryEl.textContent = '-';
            }

            setPlaybackPosition(sample) {
                // Called from the app to update current playback position
                this.lufsState.currentSample = sample;
            }

            updateRealtime() {
                if (!this.isRealtime || !this.analyserNode) return;

                const bufferLength = this.analyserNode.fftSize;
                const dataArray = new Float32Array(bufferLength);
                this.analyserNode.getFloatTimeDomainData(dataArray);

                // Calculate Peak
                let peak = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const abs = Math.abs(dataArray[i]);
                    if (abs > peak) peak = abs;
                }
                const peakDb = peak > 0 ? 20 * Math.log10(peak) : -Infinity;

                this.updatePeakDisplay(peakDb);

                // Update real-time LUFS
                this.updateRealtimeLUFS();

                this.animationFrame = requestAnimationFrame(() => this.updateRealtime());
            }

            updateRealtimeLUFS() {
                if (!this.lufsState.kWeightedChannels || this.lufsState.kWeightedChannels.length === 0) return;

                const blockSize = this.lufsState.blockSize;
                const hopSize = Math.floor(blockSize / 4); // 100ms hop
                const currentSample = this.lufsState.currentSample;
                const numChannels = this.lufsState.kWeightedChannels.length;
                const totalLength = this.lufsState.kWeightedChannels[0].length;

                // Calculate new blocks since last update
                while (this.lufsState.lastBlockSample + blockSize <= currentSample) {
                    const blockStart = this.lufsState.lastBlockSample;

                    if (blockStart + blockSize > totalLength) break;

                    // Calculate block loudness
                    let blockSum = 0;
                    for (let c = 0; c < numChannels; c++) {
                        const weight = this.getChannelWeight(c, numChannels);
                        if (weight === 0) continue;

                        const kWeighted = this.lufsState.kWeightedChannels[c];
                        let channelSum = 0;

                        for (let i = 0; i < blockSize; i++) {
                            const sample = kWeighted[blockStart + i];
                            channelSum += sample * sample;
                        }

                        blockSum += weight * (channelSum / blockSize);
                    }

                    // Store block mean square
                    const blockLUFS = blockSum > 0 ? -0.691 + 10 * Math.log10(blockSum) : -Infinity;

                    this.lufsState.integratedBlocks.push({ ms: blockSum, lufs: blockLUFS });
                    this.lufsState.shortTermBlocks.push({ ms: blockSum, lufs: blockLUFS });

                    this.lufsState.lastBlockSample += hopSize;
                }

                // Trim short-term blocks to last 3 seconds (30 blocks at 100ms hop)
                const maxShortTermBlocks = 30;
                if (this.lufsState.shortTermBlocks.length > maxShortTermBlocks) {
                    this.lufsState.shortTermBlocks = this.lufsState.shortTermBlocks.slice(-maxShortTermBlocks);
                }

                // Calculate and display LUFS values
                this.displayRealtimeLUFS();
            }

            getChannelWeight(channel, totalChannels) {
                if (totalChannels <= 2) return 1.0;
                if (channel === 3) return 0; // LFE
                if (channel >= 4) return 1.41; // Surround
                return 1.0;
            }

            displayRealtimeLUFS() {
                // Momentary (last 400ms = ~4 blocks)
                const momentaryBlocks = this.lufsState.shortTermBlocks.slice(-4);
                const momentary = this.calculateGatedLUFS(momentaryBlocks, false); // No gating for momentary
                this.lufsMomentaryEl.textContent = isFinite(momentary) ? momentary.toFixed(1) + ' LUFS' : '-';

                // Short-term (last 3 seconds)
                const shortTerm = this.calculateGatedLUFS(this.lufsState.shortTermBlocks, false); // No gating for short-term
                this.lufsShortTermEl.textContent = isFinite(shortTerm) ? shortTerm.toFixed(1) + ' LUFS' : '-';

                // Integrated (all blocks since play, with gating)
                const integrated = this.calculateGatedLUFS(this.lufsState.integratedBlocks, true);
                this.lufsIntegratedEl.textContent = isFinite(integrated) ? integrated.toFixed(1) + ' LUFS' : '-';
            }

            calculateGatedLUFS(blocks, useGating) {
                if (blocks.length === 0) return -Infinity;

                if (!useGating) {
                    // Simple average without gating
                    const sum = blocks.reduce((a, b) => a + b.ms, 0);
                    const mean = sum / blocks.length;
                    return mean > 0 ? -0.691 + 10 * Math.log10(mean) : -Infinity;
                }

                // With gating (ITU-R BS.1770-4)
                // Step 1: Absolute gating at -70 LUFS
                const absoluteThreshold = -70;
                const absoluteGated = blocks.filter(b => b.lufs > absoluteThreshold);

                if (absoluteGated.length === 0) return -Infinity;

                // Calculate ungated loudness
                const absoluteSum = absoluteGated.reduce((a, b) => a + b.ms, 0);
                const absoluteMean = absoluteSum / absoluteGated.length;
                const ungatedLoudness = absoluteMean > 0 ? -0.691 + 10 * Math.log10(absoluteMean) : -Infinity;

                // Step 2: Relative gating at -10 LU below ungated
                const relativeThreshold = ungatedLoudness - 10;
                const relativeGated = blocks.filter(b => b.lufs > relativeThreshold);

                if (relativeGated.length === 0) return -Infinity;

                // Final integrated loudness
                const finalSum = relativeGated.reduce((a, b) => a + b.ms, 0);
                const finalMean = finalSum / relativeGated.length;

                return finalMean > 0 ? -0.691 + 10 * Math.log10(finalMean) : -Infinity;
            }

            updatePeakDisplay(peakDb) {
                this.peakValue.textContent = isFinite(peakDb) ? peakDb.toFixed(1) : '-∞';
                this.peakValue.className = 'meter-value' + this.getColorClass(peakDb);
                this.peakBar.style.width = this.dbToPercent(peakDb) + '%';
            }

            getColorClass(db) {
                if (db >= -1) return ' danger';
                if (db >= -6) return ' warning';
                return '';
            }

            dbToPercent(db) {
                if (!isFinite(db)) return 0;
                // Map -60dB to 0dB to 0-100%
                return Math.max(0, Math.min(100, (db + 60) / 60 * 100));
            }

            reset() {
                this.updatePeakDisplay(-Infinity);
                this.fileStats = { rmsPeak: null, truePeak: null, lufs: null };
                this.updateFileStatsDisplay();
                // Reset real-time LUFS
                this.lufsState.kWeightedChannels = null;
                this.lufsState.integratedBlocks = [];
                this.lufsState.shortTermBlocks = [];
                this.lufsIntegratedEl.textContent = '-';
                this.lufsShortTermEl.textContent = '-';
                this.lufsMomentaryEl.textContent = '-';
            }
        }

        // ==================== File Handler ====================
        class FileHandler {
            static async importFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = (e) => reject(e);
                    reader.readAsArrayBuffer(file);
                });
            }

            // Dithering: TPDF (Triangular Probability Density Function)
            static ditherTPDF(bitDepth) {
                // Generate two uniform random numbers and subtract for triangular distribution
                const lsb = 1.0 / (1 << (bitDepth - 1));
                return (Math.random() - Math.random()) * lsb;
            }

            // Dithering: Noise shaped (simple first-order noise shaping)
            static createNoiseShaper(numChannels) {
                const errorBuffer = new Array(numChannels).fill(0);
                return {
                    process: (sample, channel, bitDepth) => {
                        const lsb = 1.0 / (1 << (bitDepth - 1));
                        // Add previous quantization error (feedback)
                        const shaped = sample + errorBuffer[channel] * 0.5;
                        // Add TPDF dither
                        const dithered = shaped + (Math.random() - Math.random()) * lsb;
                        // Quantize
                        const scale = (1 << (bitDepth - 1)) - 1;
                        const quantized = Math.round(Math.max(-1, Math.min(1, dithered)) * scale) / scale;
                        // Store error for next sample
                        errorBuffer[channel] = shaped - quantized;
                        return quantized;
                    }
                };
            }

            static exportWAV(audioBuffer, bitDepth = 16, dither = 'none') {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const length = audioBuffer.length;

                let bytesPerSample;
                let formatCode;
                if (bitDepth === 32) {
                    bytesPerSample = 4;
                    formatCode = 3; // Float
                } else {
                    bytesPerSample = bitDepth / 8;
                    formatCode = 1; // PCM
                }

                const dataSize = length * numChannels * bytesPerSample;
                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);

                // RIFF header
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + dataSize, true);
                this.writeString(view, 8, 'WAVE');

                // fmt chunk
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true); // chunk size
                view.setUint16(20, formatCode, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
                view.setUint16(32, numChannels * bytesPerSample, true);
                view.setUint16(34, bitDepth, true);

                // data chunk
                this.writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);

                // Write samples
                const channels = [];
                for (let c = 0; c < numChannels; c++) {
                    channels.push(audioBuffer.getChannelData(c));
                }

                // Set up noise shaper if needed
                const noiseShaper = dither === 'shaped' ? this.createNoiseShaper(numChannels) : null;

                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let c = 0; c < numChannels; c++) {
                        let sample = channels[c][i];

                        if (bitDepth === 32) {
                            view.setFloat32(offset, sample, true);
                        } else if (bitDepth === 24) {
                            // Apply dithering for fixed-point formats
                            if (dither === 'tpdf') {
                                sample += this.ditherTPDF(24);
                            } else if (dither === 'shaped') {
                                sample = noiseShaper.process(sample, c, 24);
                            }
                            const intSample = Math.round(Math.max(-1, Math.min(1, sample)) * 0x7FFFFF);
                            view.setUint8(offset, intSample & 0xFF);
                            view.setUint8(offset + 1, (intSample >> 8) & 0xFF);
                            view.setUint8(offset + 2, (intSample >> 16) & 0xFF);
                        } else {
                            // 16-bit
                            if (dither === 'tpdf') {
                                sample += this.ditherTPDF(16);
                            } else if (dither === 'shaped') {
                                sample = noiseShaper.process(sample, c, 16);
                            }
                            const intSample = Math.round(Math.max(-1, Math.min(1, sample)) * 0x7FFF);
                            view.setInt16(offset, intSample, true);
                        }
                        offset += bytesPerSample;
                    }
                }

                return new Blob([buffer], { type: 'audio/wav' });
            }

            static exportAIF(audioBuffer, bitDepth = 16, dither = 'none') {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const length = audioBuffer.length;
                const bytesPerSample = bitDepth / 8;

                const dataSize = length * numChannels * bytesPerSample;
                const commSize = 18;
                const ssndSize = 8 + dataSize;
                const formSize = 4 + 8 + commSize + 8 + ssndSize;

                const buffer = new ArrayBuffer(12 + 8 + commSize + 8 + ssndSize);
                const view = new DataView(buffer);

                // FORM header
                this.writeString(view, 0, 'FORM');
                view.setUint32(4, formSize, false);
                this.writeString(view, 8, 'AIFF');

                // COMM chunk
                this.writeString(view, 12, 'COMM');
                view.setUint32(16, commSize, false);
                view.setInt16(20, numChannels, false);
                view.setUint32(22, length, false);
                view.setInt16(26, bitDepth, false);
                // Sample rate as 80-bit extended float (simplified)
                this.writeExtendedFloat(view, 28, sampleRate);

                // SSND chunk
                const ssndOffset = 12 + 8 + commSize;
                this.writeString(view, ssndOffset, 'SSND');
                view.setUint32(ssndOffset + 4, ssndSize, false);
                view.setUint32(ssndOffset + 8, 0, false); // offset
                view.setUint32(ssndOffset + 12, 0, false); // block size

                // Write samples
                const channels = [];
                for (let c = 0; c < numChannels; c++) {
                    channels.push(audioBuffer.getChannelData(c));
                }

                // Set up noise shaper if needed
                const noiseShaper = dither === 'shaped' ? this.createNoiseShaper(numChannels) : null;

                let offset = ssndOffset + 16;
                for (let i = 0; i < length; i++) {
                    for (let c = 0; c < numChannels; c++) {
                        let sample = channels[c][i];

                        if (bitDepth === 24) {
                            if (dither === 'tpdf') {
                                sample += this.ditherTPDF(24);
                            } else if (dither === 'shaped') {
                                sample = noiseShaper.process(sample, c, 24);
                            }
                            const intSample = Math.round(Math.max(-1, Math.min(1, sample)) * 0x7FFFFF);
                            view.setUint8(offset, (intSample >> 16) & 0xFF);
                            view.setUint8(offset + 1, (intSample >> 8) & 0xFF);
                            view.setUint8(offset + 2, intSample & 0xFF);
                        } else if (bitDepth === 32) {
                            // 32-bit integer (not float) for AIF - no dithering needed
                            const intSample = Math.round(Math.max(-1, Math.min(1, sample)) * 0x7FFFFFFF);
                            view.setInt32(offset, intSample, false);
                        } else {
                            // 16-bit
                            if (dither === 'tpdf') {
                                sample += this.ditherTPDF(16);
                            } else if (dither === 'shaped') {
                                sample = noiseShaper.process(sample, c, 16);
                            }
                            const intSample = Math.round(Math.max(-1, Math.min(1, sample)) * 0x7FFF);
                            view.setInt16(offset, intSample, false);
                        }
                        offset += bytesPerSample;
                    }
                }

                return new Blob([buffer], { type: 'audio/aiff' });
            }

            static writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            static writeExtendedFloat(view, offset, value) {
                // Simplified 80-bit extended float for sample rate
                let exponent = 16398;
                let mantissa = value;
                while (mantissa < 32768) {
                    mantissa *= 2;
                    exponent--;
                }
                view.setUint16(offset, exponent, false);
                view.setUint32(offset + 2, mantissa * 65536, false);
                view.setUint32(offset + 6, 0, false);
            }
        }

        // ==================== Audio Editor ====================
        class AudioEditor {
            constructor(audioContext) {
                this.audioContext = audioContext;
            }

            createBuffer(length, numChannels, sampleRate) {
                return this.audioContext.createBuffer(numChannels, length, sampleRate);
            }

            trim(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const newLength = endSample - startSample;

                const newBuffer = this.createBuffer(newLength, numChannels, sampleRate);

                for (let c = 0; c < numChannels; c++) {
                    const oldData = audioBuffer.getChannelData(c);
                    const newData = newBuffer.getChannelData(c);
                    for (let i = 0; i < newLength; i++) {
                        newData[i] = oldData[startSample + i];
                    }
                }

                return newBuffer;
            }

            deleteSelection(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const sampleRate = audioBuffer.sampleRate;
                const deleteLength = endSample - startSample;
                const newLength = audioBuffer.length - deleteLength;

                if (newLength <= 0) return null;

                const newBuffer = this.createBuffer(newLength, numChannels, sampleRate);

                for (let c = 0; c < numChannels; c++) {
                    const oldData = audioBuffer.getChannelData(c);
                    const newData = newBuffer.getChannelData(c);
                    // Copy samples before selection
                    for (let i = 0; i < startSample; i++) {
                        newData[i] = oldData[i];
                    }
                    // Copy samples after selection
                    for (let i = endSample; i < audioBuffer.length; i++) {
                        newData[i - deleteLength] = oldData[i];
                    }
                }

                return newBuffer;
            }

            normalize(audioBuffer, targetDbFS = 0, startSample = 0, endSample = null) {
                if (endSample === null) endSample = audioBuffer.length;
                const numChannels = audioBuffer.numberOfChannels;

                // Find peak
                let peak = 0;
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        const abs = Math.abs(data[i]);
                        if (abs > peak) peak = abs;
                    }
                }

                if (peak === 0) return audioBuffer;

                // Calculate gain
                const targetLinear = Math.pow(10, targetDbFS / 20);
                const gain = targetLinear / peak;

                // Apply gain
                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        data[i] *= gain;
                    }
                }

                return audioBuffer;
            }

            fadeIn(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const fadeLength = endSample - startSample;

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < fadeLength; i++) {
                        const gain = i / fadeLength;
                        data[startSample + i] *= gain;
                    }
                }

                return audioBuffer;
            }

            fadeOut(audioBuffer, startSample, endSample) {
                const numChannels = audioBuffer.numberOfChannels;
                const fadeLength = endSample - startSample;

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = 0; i < fadeLength; i++) {
                        const gain = 1 - (i / fadeLength);
                        data[startSample + i] *= gain;
                    }
                }

                return audioBuffer;
            }

            applyGain(audioBuffer, gainDb, startSample = 0, endSample = null) {
                if (endSample === null) endSample = audioBuffer.length;
                const numChannels = audioBuffer.numberOfChannels;
                const gainLinear = Math.pow(10, gainDb / 20);

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    for (let i = startSample; i < endSample; i++) {
                        data[i] *= gainLinear;
                    }
                }

                return audioBuffer;
            }

            reverse(audioBuffer, startSample = 0, endSample = null) {
                if (endSample === null) endSample = audioBuffer.length;
                const numChannels = audioBuffer.numberOfChannels;

                for (let c = 0; c < numChannels; c++) {
                    const data = audioBuffer.getChannelData(c);
                    // Extract the region to reverse
                    const region = data.slice(startSample, endSample);
                    // Reverse it
                    region.reverse();
                    // Copy back
                    for (let i = 0; i < region.length; i++) {
                        data[startSample + i] = region[i];
                    }
                }

                return audioBuffer;
            }
        }

        // ==================== Utility Functions ====================
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(2);
            return `${mins}:${secs.padStart(5, '0')}`;
        }

        // ==================== Undo Manager ====================
        class UndoManager {
            constructor(audioContext, maxStates = 50) {
                this.audioContext = audioContext;
                this.undoStack = [];
                this.redoStack = [];
                this.maxStates = maxStates;
            }

            setAudioContext(ctx) {
                this.audioContext = ctx;
            }

            // Save current state before making changes
            saveState(audioBuffer) {
                if (!audioBuffer) return;

                // Clone the audio buffer
                const clone = this.cloneBuffer(audioBuffer);
                this.undoStack.push(clone);

                // Clear redo stack when new action is performed
                this.redoStack = [];

                // Limit stack size
                if (this.undoStack.length > this.maxStates) {
                    this.undoStack.shift();
                }
            }

            canUndo() {
                return this.undoStack.length > 0;
            }

            canRedo() {
                return this.redoStack.length > 0;
            }

            undo(currentBuffer) {
                if (!this.canUndo()) return null;

                // Save current state to redo stack
                if (currentBuffer) {
                    this.redoStack.push(this.cloneBuffer(currentBuffer));
                }

                // Pop and return the previous state
                return this.undoStack.pop();
            }

            redo(currentBuffer) {
                if (!this.canRedo()) return null;

                // Save current state to undo stack
                if (currentBuffer) {
                    this.undoStack.push(this.cloneBuffer(currentBuffer));
                }

                // Pop and return the redo state
                return this.redoStack.pop();
            }

            cloneBuffer(audioBuffer) {
                const clone = this.audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    audioBuffer.length,
                    audioBuffer.sampleRate
                );

                for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
                    const sourceData = audioBuffer.getChannelData(c);
                    const destData = clone.getChannelData(c);
                    destData.set(sourceData);
                }

                return clone;
            }

            clear() {
                this.undoStack = [];
                this.redoStack = [];
            }
        }

        // ==================== File Queue Manager ====================
        class FileQueue {
            constructor() {
                this.files = [];
                this.activeFileId = null;
            }

            addFile(file) {
                const id = Date.now() + Math.random();
                this.files.push({ id, file, cuePoints: [] });
                return id;
            }

            addFiles(fileList) {
                const ids = [];
                for (const file of fileList) {
                    ids.push(this.addFile(file));
                }
                return ids;
            }

            removeFile(id) {
                const index = this.files.findIndex(f => f.id === id);
                if (index !== -1) {
                    this.files.splice(index, 1);
                    if (this.activeFileId === id) {
                        this.activeFileId = null;
                    }
                }
            }

            getFile(id) {
                const item = this.files.find(f => f.id === id);
                return item ? item.file : null;
            }

            setActive(id) {
                this.activeFileId = id;
            }

            getActive() {
                return this.activeFileId;
            }

            getAll() {
                return this.files;
            }

            // Store cue points for a file
            setCuePoints(id, cuePoints) {
                const item = this.files.find(f => f.id === id);
                if (item) {
                    item.cuePoints = cuePoints;
                }
            }

            // Get cue points for a file
            getCuePoints(id) {
                const item = this.files.find(f => f.id === id);
                return item ? item.cuePoints : [];
            }
        }

        // ==================== Cue Point Manager ====================
        class CuePointManager {
            constructor() {
                this.cuePoints = [];
                this.nextId = 1;
            }

            addCuePoint(sample, name = '') {
                const cuePoint = {
                    id: this.nextId++,
                    sample: sample,
                    number: this.cuePoints.length + 1,
                    name: name
                };
                this.cuePoints.push(cuePoint);
                this.sortCuePoints();
                this.renumberCuePoints();
                return cuePoint;
            }

            removeCuePoint(id) {
                const index = this.cuePoints.findIndex(c => c.id === id);
                if (index !== -1) {
                    this.cuePoints.splice(index, 1);
                    this.renumberCuePoints();
                }
            }

            moveCuePoint(id, newSample) {
                const cuePoint = this.cuePoints.find(c => c.id === id);
                if (cuePoint) {
                    cuePoint.sample = Math.max(0, newSample);
                    this.sortCuePoints();
                    this.renumberCuePoints();
                }
            }

            renameCuePoint(id, newName) {
                const cuePoint = this.cuePoints.find(c => c.id === id);
                if (cuePoint) {
                    cuePoint.name = newName;
                }
            }

            getCuePoint(id) {
                return this.cuePoints.find(c => c.id === id);
            }

            getCuePointAtSample(sample, tolerance = 0) {
                return this.cuePoints.find(c => Math.abs(c.sample - sample) <= tolerance);
            }

            getCuePointsInRange(startSample, endSample) {
                return this.cuePoints.filter(c => c.sample >= startSample && c.sample <= endSample);
            }

            getAdjacentCuePoints(sample) {
                let prev = null;
                let next = null;
                for (const cp of this.cuePoints) {
                    if (cp.sample < sample) {
                        prev = cp;
                    } else if (cp.sample > sample && next === null) {
                        next = cp;
                        break;
                    }
                }
                return { prev, next };
            }

            sortCuePoints() {
                this.cuePoints.sort((a, b) => a.sample - b.sample);
            }

            renumberCuePoints() {
                this.cuePoints.forEach((cp, index) => {
                    cp.number = index + 1;
                });
            }

            getAllCuePoints() {
                return this.cuePoints;
            }

            clear() {
                this.cuePoints = [];
                this.nextId = 1;
            }

            // Adjust cue points after a region is deleted from the waveform
            adjustForDeletion(startSample, endSample) {
                const deleteLength = endSample - startSample;

                // Remove cue points within the deleted region
                this.cuePoints = this.cuePoints.filter(cp => {
                    return cp.sample < startSample || cp.sample >= endSample;
                });

                // Shift cue points after the deleted region
                this.cuePoints.forEach(cp => {
                    if (cp.sample >= endSample) {
                        cp.sample -= deleteLength;
                    }
                });

                this.renumberCuePoints();
            }

            // Adjust cue points after trimming (keeping only a region)
            adjustForTrim(startSample, endSample) {
                // Keep only cue points within the trim region, and shift them
                this.cuePoints = this.cuePoints.filter(cp => {
                    return cp.sample >= startSample && cp.sample < endSample;
                });

                // Shift all remaining cue points by startSample
                this.cuePoints.forEach(cp => {
                    cp.sample -= startSample;
                });

                this.renumberCuePoints();
            }

            toJSON() {
                return this.cuePoints.map(cp => ({
                    sample: cp.sample,
                    name: cp.name
                }));
            }

            fromJSON(data) {
                this.clear();
                if (Array.isArray(data)) {
                    data.forEach(cp => {
                        this.addCuePoint(cp.sample, cp.name || '');
                    });
                }
            }
        }

        // ==================== Cue Point Renderer ====================
        class CuePointRenderer {
            constructor(canvas, cuePointManager) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cuePointManager = cuePointManager;
                this.audioBuffer = null;
                this.scrollOffset = 0;
                this.samplesPerPixel = 100;
                this.playheadPosition = 0;

                // Interaction state
                this.draggingCuePoint = null;
                this.dragStartX = 0;
                this.hoveredCuePoint = null;

                // Callbacks
                this.onCuePointClick = null;
                this.onCuePointDoubleClick = null;
                this.onCuePointMove = null;
                this.onCuePointRemove = null;
                this.onRegionSelect = null;
                this.onAddCuePoint = null;

                this.setupResize();
                this.setupInteraction();
            }

            setupResize() {
                const resizeObserver = new ResizeObserver(() => this.resize());
                resizeObserver.observe(this.canvas.parentElement);
                this.resize();
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                this.render();
            }

            setupInteraction() {
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseLeave(e));
                this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));
            }

            pixelToSample(x) {
                return Math.floor(this.scrollOffset + x * this.samplesPerPixel);
            }

            sampleToPixel(sample) {
                return (sample - this.scrollOffset) / this.samplesPerPixel;
            }

            getCuePointAtPixel(x, tolerance = 10) {
                const cuePoints = this.cuePointManager.getAllCuePoints();
                for (const cp of cuePoints) {
                    const cpX = this.sampleToPixel(cp.sample);
                    if (Math.abs(x - cpX) <= tolerance) {
                        return cp;
                    }
                }
                return null;
            }

            onMouseDown(e) {
                if (!this.audioBuffer) return;

                const x = e.offsetX;
                const cuePoint = this.getCuePointAtPixel(x);

                // Cmd/Ctrl+click on cue point to remove
                if ((e.metaKey || e.ctrlKey) && cuePoint) {
                    if (this.onCuePointRemove) {
                        this.onCuePointRemove(cuePoint.id);
                    }
                    return;
                }

                // Shift+click to add cue point at click position
                if (e.shiftKey) {
                    const sample = this.pixelToSample(x);
                    if (sample >= 0 && sample < this.audioBuffer.length) {
                        if (this.onAddCuePoint) {
                            this.onAddCuePoint(sample);
                        }
                    }
                    return;
                }

                if (cuePoint) {
                    // Start potential drag
                    this.draggingCuePoint = cuePoint;
                    this.dragStartX = x;
                    this.dragStartSample = cuePoint.sample;
                    this.hasDragged = false;
                    this.canvas.style.cursor = 'grabbing';
                }
            }

            onMouseMove(e) {
                if (!this.audioBuffer) return;

                const x = e.offsetX;

                if (this.draggingCuePoint) {
                    // Check if we've moved enough to count as a drag
                    if (Math.abs(x - this.dragStartX) > 5) {
                        this.hasDragged = true;
                    }
                    if (this.hasDragged) {
                        // Dragging a cue point
                        const newSample = Math.max(0, Math.min(this.audioBuffer.length, this.pixelToSample(x)));
                        if (this.onCuePointMove) {
                            this.onCuePointMove(this.draggingCuePoint.id, newSample);
                        }
                    }
                } else {
                    // Check for hover
                    const cuePoint = this.getCuePointAtPixel(x);
                    if (cuePoint !== this.hoveredCuePoint) {
                        this.hoveredCuePoint = cuePoint;
                        this.canvas.style.cursor = cuePoint ? 'grab' : 'default';
                        this.render();
                    }
                }
            }

            onMouseUp(e) {
                if (this.draggingCuePoint) {
                    if (!this.hasDragged) {
                        // It was a click, not a drag - play from this cue point
                        if (this.onCuePointClick) {
                            this.onCuePointClick(this.draggingCuePoint);
                        }
                    }
                    this.draggingCuePoint = null;
                    this.hasDragged = false;
                    this.canvas.style.cursor = this.hoveredCuePoint ? 'grab' : 'default';
                }
            }

            onMouseLeave(e) {
                this.hoveredCuePoint = null;
                this.draggingCuePoint = null;
                this.canvas.style.cursor = 'default';
                this.render();
            }

            onDoubleClick(e) {
                if (!this.audioBuffer) return;

                const x = e.offsetX;
                const clickedCuePoint = this.getCuePointAtPixel(x);

                if (clickedCuePoint) {
                    // Double-click on cue point: play from that point
                    if (this.onCuePointDoubleClick) {
                        this.onCuePointDoubleClick(clickedCuePoint);
                    }
                } else {
                    // Double-click between cue points: select region between adjacent cue points
                    const clickSample = this.pixelToSample(x);
                    const { prev, next } = this.cuePointManager.getAdjacentCuePoints(clickSample);

                    const startSample = prev ? prev.sample : 0;
                    const endSample = next ? next.sample : this.audioBuffer.length;

                    if (this.onRegionSelect) {
                        this.onRegionSelect(startSample, endSample);
                    }
                }
            }

            setAudioBuffer(buffer) {
                this.audioBuffer = buffer;
                this.render();
            }

            setScrollOffset(offset) {
                this.scrollOffset = offset;
                this.render();
            }

            setSamplesPerPixel(spp) {
                this.samplesPerPixel = spp;
                this.render();
            }

            setPlayheadPosition(sample) {
                this.playheadPosition = sample;
                this.render();
            }

            render() {
                const ctx = this.ctx;
                const width = this.width;
                const height = this.height;

                // Clear
                ctx.fillStyle = '#252525';
                ctx.fillRect(0, 0, width, height);

                if (!this.audioBuffer) {
                    ctx.fillStyle = '#444';
                    ctx.font = '11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('Cue Points', width / 2, height / 2 + 4);
                    return;
                }

                // Draw timeline background grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height - 1);
                ctx.lineTo(width, height - 1);
                ctx.stroke();

                // Draw file end indicator
                const fileEndX = this.sampleToPixel(this.audioBuffer.length);
                if (fileEndX >= 0 && fileEndX <= width) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(fileEndX, 0, width - fileEndX, height);
                }

                // Draw cue points
                const cuePoints = this.cuePointManager.getAllCuePoints();
                for (const cp of cuePoints) {
                    this.drawCuePoint(ctx, cp, cp === this.hoveredCuePoint || cp === this.draggingCuePoint);
                }

                // Draw playhead
                const playheadX = this.sampleToPixel(this.playheadPosition);
                if (playheadX >= 0 && playheadX <= width) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                }
            }

            drawCuePoint(ctx, cuePoint, isHighlighted) {
                const x = this.sampleToPixel(cuePoint.sample);
                if (x < -20 || x > this.width + 20) return;

                const flagHeight = 20;
                const flagWidth = 8;

                // Draw vertical line
                ctx.strokeStyle = isHighlighted ? '#fbbf24' : '#f59e0b';
                ctx.lineWidth = isHighlighted ? 2 : 1;
                ctx.beginPath();
                ctx.moveTo(x, flagHeight);
                ctx.lineTo(x, this.height);
                ctx.stroke();

                // Draw flag
                ctx.fillStyle = isHighlighted ? '#fbbf24' : '#f59e0b';
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x + flagWidth, flagHeight / 2);
                ctx.lineTo(x, flagHeight);
                ctx.closePath();
                ctx.fill();

                // Draw number in flag
                ctx.fillStyle = '#000';
                ctx.font = 'bold 9px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(cuePoint.number.toString(), x + 1, flagHeight / 2 + 3);

                // Draw name label
                if (cuePoint.name) {
                    ctx.fillStyle = isHighlighted ? '#fbbf24' : '#aaa';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText(cuePoint.name, x + flagWidth + 4, flagHeight / 2 + 3);
                }
            }
        }

        // ==================== Project Manager ====================
        class ProjectManager {
            static async saveProject(audioBuffer, cuePointManager, fileName, metadata = {}) {
                const project = {
                    version: 1,
                    fileName: fileName,
                    metadata: metadata,
                    audio: {
                        sampleRate: audioBuffer.sampleRate,
                        numberOfChannels: audioBuffer.numberOfChannels,
                        length: audioBuffer.length,
                        channels: []
                    },
                    cuePoints: cuePointManager.toJSON()
                };

                // Encode audio data as base64
                for (let c = 0; c < audioBuffer.numberOfChannels; c++) {
                    const channelData = audioBuffer.getChannelData(c);
                    const buffer = new ArrayBuffer(channelData.length * 4);
                    const view = new Float32Array(buffer);
                    view.set(channelData);
                    const base64 = ProjectManager.arrayBufferToBase64(buffer);
                    project.audio.channels.push(base64);
                }

                return JSON.stringify(project);
            }

            static async loadProject(jsonString, audioContext) {
                const project = JSON.parse(jsonString);

                if (!project.version || project.version > 1) {
                    throw new Error('Unsupported project version');
                }

                // Decode audio data
                const audioBuffer = audioContext.createBuffer(
                    project.audio.numberOfChannels,
                    project.audio.length,
                    project.audio.sampleRate
                );

                for (let c = 0; c < project.audio.numberOfChannels; c++) {
                    const buffer = ProjectManager.base64ToArrayBuffer(project.audio.channels[c]);
                    const channelData = new Float32Array(buffer);
                    audioBuffer.getChannelData(c).set(channelData);
                }

                return {
                    audioBuffer: audioBuffer,
                    cuePoints: project.cuePoints,
                    fileName: project.fileName,
                    metadata: project.metadata
                };
            }

            static arrayBufferToBase64(buffer) {
                let binary = '';
                const bytes = new Uint8Array(buffer);
                const len = bytes.byteLength;
                for (let i = 0; i < len; i++) {
                    binary += String.fromCharCode(bytes[i]);
                }
                return btoa(binary);
            }

            static base64ToArrayBuffer(base64) {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            static downloadProject(jsonString, fileName) {
                const baseName = fileName ? fileName.replace(/\.[^/.]+$/, '') : 'project';
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = baseName + '.seproj';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // ==================== Main Application ====================
        class App {
            constructor() {
                this.audioEngine = new AudioEngine();
                this.waveformRenderer = new WaveformRenderer(document.getElementById('waveformCanvas'));
                this.undoManager = new UndoManager(null);
                this.spectrogramRenderer = new SpectrogramRenderer(document.getElementById('spectrogramCanvas'));
                this.metering = new Metering();
                this.audioEditor = null;
                this.fileName = null;
                this.fileQueue = new FileQueue();

                // Cue point system
                this.cuePointManager = new CuePointManager();
                this.cuePointRenderer = new CuePointRenderer(
                    document.getElementById('cuepointCanvas'),
                    this.cuePointManager
                );

                this.setupEventListeners();
                this.setupCuePointCallbacks();
                this.setupDragAndDrop();
                this.updateUI();
            }

            setupEventListeners() {
                // File operations
                document.getElementById('importBtn').addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
                document.getElementById('fileInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        const files = Array.from(e.target.files);
                        this.addFilesToQueue(files);
                    }
                    e.target.value = ''; // Reset input
                });
                document.getElementById('exportBtn').addEventListener('click', () => this.showExportModal());
                document.getElementById('saveProjectBtn').addEventListener('click', () => this.saveProject());
                document.getElementById('loadProjectBtn').addEventListener('click', () => {
                    document.getElementById('projectInput').click();
                });
                document.getElementById('projectInput').addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadProject(e.target.files[0]);
                    }
                    e.target.value = '';
                });
                document.getElementById('addCueBtn').addEventListener('click', () => this.addCuePointAtPlayhead());

                // Transport
                document.getElementById('playBtn').addEventListener('click', () => this.play());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('loopBtn').addEventListener('click', () => this.toggleLoop());

                // Zoom
                document.getElementById('zoomInBtn').addEventListener('click', () => this.waveformRenderer.zoomIn());
                document.getElementById('zoomOutBtn').addEventListener('click', () => this.waveformRenderer.zoomOut());
                document.getElementById('zoomFitBtn').addEventListener('click', () => this.waveformRenderer.zoomFit());

                // Edit operations
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());
                document.getElementById('trimBtn').addEventListener('click', () => this.trim());
                document.getElementById('normalizeBtn').addEventListener('click', () => this.showNormalizeModal());
                document.getElementById('fadeInBtn').addEventListener('click', () => this.fadeIn());
                document.getElementById('fadeOutBtn').addEventListener('click', () => this.fadeOut());
                document.getElementById('gainBtn').addEventListener('click', () => this.showGainModal());
                document.getElementById('reverseBtn').addEventListener('click', () => this.reverse());

                // Export modal
                document.getElementById('exportCancelBtn').addEventListener('click', () => this.hideExportModal());
                document.getElementById('exportConfirmBtn').addEventListener('click', () => this.exportFile());

                // Normalize modal
                document.getElementById('normalizeCancelBtn').addEventListener('click', () => this.hideNormalizeModal());
                document.getElementById('normalizeConfirmBtn').addEventListener('click', () => this.normalize());

                // Gain modal
                document.getElementById('gainCancelBtn').addEventListener('click', () => this.hideGainModal());
                document.getElementById('gainConfirmBtn').addEventListener('click', () => this.applyGain());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => this.handleKeyboard(e));

                // FFT size selector
                document.getElementById('fftSize').addEventListener('change', (e) => {
                    const size = parseInt(e.target.value);
                    this.audioEngine.setFFTSize(size);
                    this.spectrogramRenderer.setFFTSize(size);
                    this.spectrogramRenderer.render();
                });

                // Volume slider
                document.getElementById('volumeSlider').addEventListener('input', (e) => {
                    const db = parseFloat(e.target.value);
                    this.audioEngine.setVolume(db);
                    document.getElementById('volumeValue').textContent = db.toFixed(1) + ' dB';
                });

                // Waveform callbacks
                this.waveformRenderer.onPlayheadChange = (sample) => {
                    this.spectrogramRenderer.setPlayheadPosition(sample);
                    if (this.audioEngine.audioBuffer) {
                        const time = sample / this.audioEngine.audioBuffer.sampleRate;
                        this.updatePositionInfo(time);
                    }
                    this.updateAnalysis();
                };
                this.waveformRenderer.onSelectionUpdate = (start, end) => {
                    this.spectrogramRenderer.setSelection(start, end);
                };
                this.waveformRenderer.onSelectionChange = () => {
                    this.updateUI();
                    this.updateAnalysis();
                };
                this.waveformRenderer.onZoomChange = () => {
                    this.updateZoomInfo();
                    this.spectrogramRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);
                    this.spectrogramRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);
                };
                this.waveformRenderer.onScrollChange = () => {
                    this.spectrogramRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);
                };

                // Playback callbacks
                this.audioEngine.onPositionUpdate = (time) => {
                    this.waveformRenderer.setPlayheadPosition(time);
                    this.updatePositionInfo(time);
                    if (this.audioEngine.audioBuffer) {
                        const sample = Math.floor(time * this.audioEngine.audioBuffer.sampleRate);
                        this.spectrogramRenderer.setPlayheadPosition(sample);
                        this.cuePointRenderer.setPlayheadPosition(sample);
                        this.metering.setPlaybackPosition(sample);
                    }
                };
                this.audioEngine.onPlaybackEnd = () => {
                    this.updateUI();
                    this.stopRealtimeAnalysis();
                    this.updateAnalysis();
                };
            }

            setupCuePointCallbacks() {
                // Single click on cue point flag - play from that point
                this.cuePointRenderer.onCuePointClick = (cuePoint) => {
                    if (!this.audioEngine.audioBuffer) return;
                    const time = cuePoint.sample / this.audioEngine.audioBuffer.sampleRate;
                    this.stop();
                    this.waveformRenderer.playheadPosition = cuePoint.sample;
                    this.waveformRenderer.selectionStart = null;
                    this.waveformRenderer.selectionEnd = null;
                    this.waveformRenderer.render();
                    this.waveformRenderer.updateSelectionInfo();
                    this.spectrogramRenderer.setSelection(null, null);
                    this.audioEngine.play(time);
                    this.startRealtimeAnalysis();
                    this.updateUI();
                };

                // Double click on cue point - same as single click (play from that point)
                this.cuePointRenderer.onCuePointDoubleClick = (cuePoint) => {
                    if (!this.audioEngine.audioBuffer) return;
                    const time = cuePoint.sample / this.audioEngine.audioBuffer.sampleRate;
                    this.stop();
                    this.waveformRenderer.playheadPosition = cuePoint.sample;
                    this.waveformRenderer.render();
                    this.audioEngine.play(time);
                    this.startRealtimeAnalysis();
                    this.updateUI();
                };

                // Cue point move
                this.cuePointRenderer.onCuePointMove = (id, newSample) => {
                    this.cuePointManager.moveCuePoint(id, newSample);
                    this.cuePointRenderer.render();
                };

                // Cue point remove (Cmd/Ctrl+click)
                this.cuePointRenderer.onCuePointRemove = (id) => {
                    this.cuePointManager.removeCuePoint(id);
                    this.cuePointRenderer.render();
                };

                // Add cue point (shift+click in cue lane)
                this.cuePointRenderer.onAddCuePoint = (sample) => {
                    this.pendingCuePointSample = sample;
                    const cuepointInput = document.getElementById('cuepointInput');
                    const cuepointNameInput = document.getElementById('cuepointNameInput');
                    const playheadX = this.cuePointRenderer.sampleToPixel(sample);
                    cuepointInput.style.left = Math.max(10, Math.min(playheadX, this.cuePointRenderer.width - 150)) + 'px';
                    cuepointInput.style.top = '4px';
                    cuepointInput.classList.add('visible');
                    cuepointNameInput.focus();
                };

                // Region select (double-click between cue points)
                this.cuePointRenderer.onRegionSelect = (startSample, endSample) => {
                    this.waveformRenderer.selectionStart = startSample;
                    this.waveformRenderer.selectionEnd = endSample;
                    this.waveformRenderer.render();
                    this.waveformRenderer.updateSelectionInfo();
                    this.spectrogramRenderer.setSelection(startSample, endSample);
                    this.updateUI();
                };

                // Sync cue point renderer with waveform zoom/scroll
                const originalOnZoomChange = this.waveformRenderer.onZoomChange;
                this.waveformRenderer.onZoomChange = () => {
                    if (originalOnZoomChange) originalOnZoomChange();
                    this.cuePointRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);
                    this.cuePointRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);
                };

                const originalOnScrollChange = this.waveformRenderer.onScrollChange;
                this.waveformRenderer.onScrollChange = () => {
                    if (originalOnScrollChange) originalOnScrollChange();
                    this.cuePointRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);
                };

                // Sync playhead position
                const originalOnPlayheadChange = this.waveformRenderer.onPlayheadChange;
                this.waveformRenderer.onPlayheadChange = (sample) => {
                    if (originalOnPlayheadChange) originalOnPlayheadChange(sample);
                    this.cuePointRenderer.setPlayheadPosition(sample);
                };

                // Cue point name input handling
                const cuepointInput = document.getElementById('cuepointInput');
                const cuepointNameInput = document.getElementById('cuepointNameInput');

                cuepointNameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        const name = cuepointNameInput.value.trim();
                        if (this.pendingCuePointSample !== undefined) {
                            this.cuePointManager.addCuePoint(this.pendingCuePointSample, name);
                            this.cuePointRenderer.render();
                            this.pendingCuePointSample = undefined;
                        }
                        cuepointInput.classList.remove('visible');
                        cuepointNameInput.value = '';
                    } else if (e.key === 'Escape') {
                        cuepointInput.classList.remove('visible');
                        cuepointNameInput.value = '';
                        this.pendingCuePointSample = undefined;
                    }
                });

                cuepointNameInput.addEventListener('blur', () => {
                    // Add cue point with current name when clicking away
                    const name = cuepointNameInput.value.trim();
                    if (this.pendingCuePointSample !== undefined) {
                        this.cuePointManager.addCuePoint(this.pendingCuePointSample, name);
                        this.cuePointRenderer.render();
                        this.pendingCuePointSample = undefined;
                    }
                    cuepointInput.classList.remove('visible');
                    cuepointNameInput.value = '';
                });
            }

            handleKeyboard(e) {
                if (e.target.tagName === 'INPUT') return;

                // Handle Cmd/Ctrl + key combinations
                if (e.metaKey || e.ctrlKey) {
                    switch (e.key) {
                        case 'a':
                            e.preventDefault();
                            this.waveformRenderer.selectAll();
                            return;
                        case 'z':
                            e.preventDefault();
                            if (e.shiftKey) {
                                this.redo();
                            } else {
                                this.undo();
                            }
                            return;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            return;
                        case 't':
                            e.preventDefault();
                            if (this.waveformRenderer.hasSelection()) {
                                this.trim();
                            }
                            return;
                        case 'f':
                            e.preventDefault();
                            if (e.shiftKey) {
                                // Cmd/Ctrl + Shift + F = Fade Out
                                if (this.waveformRenderer.hasSelection()) {
                                    this.fadeOut();
                                }
                            } else {
                                // Cmd/Ctrl + F = Fade In
                                if (this.waveformRenderer.hasSelection()) {
                                    this.fadeIn();
                                }
                            }
                            return;
                        case 'n':
                            e.preventDefault();
                            if (e.shiftKey) {
                                // Cmd/Ctrl + Shift + N = Normalize
                                if (this.audioEngine.audioBuffer) {
                                    this.showNormalizeModal();
                                }
                            }
                            return;
                    }
                }

                switch (e.key) {
                    case ' ':
                        e.preventDefault();
                        if (this.audioEngine.isPlaying) {
                            this.pause();
                        } else {
                            this.play();
                        }
                        break;
                    case '+':
                    case '=':
                        this.waveformRenderer.zoomIn();
                        break;
                    case '-':
                        this.waveformRenderer.zoomOut();
                        break;
                    case 'ArrowLeft':
                        e.preventDefault();
                        if (this.audioEngine.audioBuffer) {
                            this.movePlayhead(-1); // Move back 1ms
                        }
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        if (this.audioEngine.audioBuffer) {
                            this.movePlayhead(1); // Move forward 1ms
                        }
                        break;
                    case 'Delete':
                    case 'Backspace':
                        e.preventDefault();
                        this.deleteSelection();
                        break;
                    case 'l':
                    case 'L':
                        if (this.audioEngine.audioBuffer) {
                            this.toggleLoop();
                        }
                        break;
                    case 'r':
                    case 'R':
                        if (this.audioEngine.audioBuffer) {
                            this.reverse();
                        }
                        break;
                    case 'm':
                    case 'M':
                        if (this.audioEngine.audioBuffer) {
                            this.addCuePointAtPlayhead();
                        }
                        break;
                }
            }

            async importFile(file, fileId = null) {
                try {
                    this.fileName = file.name;
                    const arrayBuffer = await FileHandler.importFile(file);
                    const audioBuffer = await this.audioEngine.loadAudio(arrayBuffer);

                    if (!this.audioEditor) {
                        this.audioEditor = new AudioEditor(this.audioEngine.audioContext);
                    }

                    // Set up undo manager
                    this.undoManager.setAudioContext(this.audioEngine.audioContext);
                    this.undoManager.clear();

                    // Set up waveform
                    this.waveformRenderer.setAudioBuffer(audioBuffer);

                    // Set up spectrogram
                    this.spectrogramRenderer.setAudioBuffer(audioBuffer);
                    this.spectrogramRenderer.setAnalyserNode(this.audioEngine.getAnalyserNode());
                    this.spectrogramRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);

                    // Set up metering
                    this.metering.setAudioBuffer(audioBuffer);
                    this.metering.setAnalyserNode(this.audioEngine.getAnalyserNode());

                    // Set up cue point renderer
                    this.cuePointManager.clear();
                    this.cuePointRenderer.setAudioBuffer(audioBuffer);
                    this.cuePointRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);
                    this.cuePointRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);

                    // Update active file in queue and restore cue points
                    if (fileId) {
                        // Load cue points for this file from the queue
                        const savedCuePoints = this.fileQueue.getCuePoints(fileId);
                        if (savedCuePoints && savedCuePoints.length > 0) {
                            this.cuePointManager.fromJSON(savedCuePoints);
                            this.cuePointRenderer.render();
                        }
                        this.fileQueue.setActive(fileId);
                        this.renderFileList();
                    }

                    this.updateUI();
                    this.updateFileInfo();
                    this.updateZoomInfo();
                    this.updateAnalysis();
                } catch (err) {
                    alert('Error loading audio file: ' + err.message);
                }
            }

            setupDragAndDrop() {
                const waveformContainer = document.querySelector('.waveform-container');
                const dragOverlay = document.getElementById('dragOverlay');

                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    waveformContainer.addEventListener(eventName, (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                    }, false);
                });

                // Show overlay on drag enter/over
                ['dragenter', 'dragover'].forEach(eventName => {
                    waveformContainer.addEventListener(eventName, () => {
                        dragOverlay.classList.add('visible');
                    }, false);
                });

                // Hide overlay on drag leave
                waveformContainer.addEventListener('dragleave', (e) => {
                    if (e.target === waveformContainer) {
                        dragOverlay.classList.remove('visible');
                    }
                }, false);

                // Handle drop
                waveformContainer.addEventListener('drop', (e) => {
                    dragOverlay.classList.remove('visible');
                    const files = Array.from(e.dataTransfer.files).filter(f =>
                        f.name.toLowerCase().endsWith('.wav') ||
                        f.name.toLowerCase().endsWith('.aif') ||
                        f.name.toLowerCase().endsWith('.aiff')
                    );

                    if (files.length > 0) {
                        this.addFilesToQueue(files);
                    }
                }, false);
            }

            addFilesToQueue(files) {
                const ids = this.fileQueue.addFiles(files);
                this.renderFileList();

                // Auto-load the first file if nothing is currently loaded
                if (!this.audioEngine.audioBuffer && files.length > 0) {
                    this.loadFileFromQueue(ids[0]);
                }
            }

            loadFileFromQueue(fileId) {
                // Save current cue points to the current file before switching
                const currentFileId = this.fileQueue.getActive();
                if (currentFileId) {
                    this.fileQueue.setCuePoints(currentFileId, this.cuePointManager.toJSON());
                }

                const file = this.fileQueue.getFile(fileId);
                if (file) {
                    this.importFile(file, fileId);
                }
            }

            removeFileFromQueue(fileId) {
                const wasActive = this.fileQueue.getActive() === fileId;
                this.fileQueue.removeFile(fileId);
                this.renderFileList();

                // If we removed the active file, clear the editor
                if (wasActive) {
                    this.audioEngine.stop();
                    this.audioEngine.audioBuffer = null;
                    this.waveformRenderer.setAudioBuffer(null);
                    this.spectrogramRenderer.setAudioBuffer(null);
                    this.cuePointManager.clear();
                    this.cuePointRenderer.setAudioBuffer(null);
                    this.fileName = null;
                    this.updateUI();
                    this.updateFileInfo();

                    // Load the first remaining file if any
                    const files = this.fileQueue.getAll();
                    if (files.length > 0) {
                        this.loadFileFromQueue(files[0].id);
                    }
                }
            }

            renderFileList() {
                const fileListContainer = document.getElementById('fileList');
                const activeId = this.fileQueue.getActive();
                const files = this.fileQueue.getAll();

                fileListContainer.innerHTML = '';

                files.forEach(({ id, file }) => {
                    const item = document.createElement('div');
                    item.className = 'file-item';
                    if (id === activeId) {
                        item.classList.add('active');
                    }

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'file-name';
                    nameSpan.textContent = file.name;
                    nameSpan.title = file.name;

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'file-delete';
                    deleteBtn.innerHTML = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        this.removeFileFromQueue(id);
                    };

                    item.onclick = () => {
                        if (id !== activeId) {
                            this.loadFileFromQueue(id);
                        }
                    };

                    item.appendChild(nameSpan);
                    item.appendChild(deleteBtn);
                    fileListContainer.appendChild(item);
                });
            }

            play() {
                if (!this.audioEngine.audioBuffer) return;

                const selection = this.waveformRenderer.getSelection();
                if (selection) {
                    // Always play only the selection
                    const startTime = selection.start / this.audioEngine.audioBuffer.sampleRate;
                    const endTime = selection.end / this.audioEngine.audioBuffer.sampleRate;
                    this.audioEngine.playSelection(startTime, endTime);
                } else if (this.audioEngine.isPaused) {
                    // Resume from pause point
                    this.audioEngine.resume();
                } else {
                    // Play from playhead position, or from start if at/near end
                    let startSample = this.waveformRenderer.playheadPosition;
                    const totalSamples = this.audioEngine.audioBuffer.length;

                    // If playhead is within 1% of the end, start from beginning
                    if (startSample >= totalSamples * 0.99) {
                        startSample = 0;
                        this.waveformRenderer.playheadPosition = 0;
                        this.waveformRenderer.render();
                    }

                    const startTime = startSample / this.audioEngine.audioBuffer.sampleRate;
                    this.audioEngine.play(startTime);
                }
                this.startRealtimeAnalysis();
                this.updateUI();
            }

            pause() {
                this.audioEngine.pause();
                this.stopRealtimeAnalysis();
                this.updateUI();
            }

            stop() {
                this.audioEngine.stop();
                this.stopRealtimeAnalysis();
                this.waveformRenderer.setPlayheadPosition(0);
                this.spectrogramRenderer.setPlayheadPosition(0);
                this.updatePositionInfo(0);
                this.updateUI();
                this.updateAnalysis();
            }

            toggleLoop() {
                const isLooping = !this.audioEngine.isLooping();
                this.audioEngine.setLooping(isLooping);
                document.getElementById('loopBtn').classList.toggle('loop-active', isLooping);
            }

            movePlayhead(milliseconds) {
                if (!this.audioEngine.audioBuffer) return;

                const sampleRate = this.audioEngine.audioBuffer.sampleRate;
                const totalSamples = this.audioEngine.audioBuffer.length;

                // Convert milliseconds to samples (1ms = sampleRate/1000 samples)
                const sampleIncrement = Math.round((sampleRate / 1000) * milliseconds);

                // Get current playhead position in samples
                let currentSample = this.waveformRenderer.playheadPosition;

                // Calculate new position
                let newSample = currentSample + sampleIncrement;

                // Clamp to valid range
                newSample = Math.max(0, Math.min(totalSamples - 1, newSample));

                // Update playhead position
                this.waveformRenderer.playheadPosition = newSample;
                this.waveformRenderer.render();

                // Update spectrum at new position
                this.spectrogramRenderer.setPlayheadPosition(newSample);
                this.spectrogramRenderer.render();

                // Update position info
                const time = newSample / sampleRate;
                this.updatePositionInfo(time);
            }

            startRealtimeAnalysis() {
                this.spectrogramRenderer.startRealtime();
                this.metering.startRealtime();
            }

            stopRealtimeAnalysis() {
                this.spectrogramRenderer.stopRealtime();
                this.metering.stopRealtime();
            }

            updateAnalysis() {
                // File-wide stats are calculated when file is loaded
                // Real-time metering happens during playback
                // No need for additional analysis here
            }

            undo() {
                if (!this.undoManager.canUndo()) return;

                this.stop();
                const previousBuffer = this.undoManager.undo(this.audioEngine.audioBuffer);
                if (previousBuffer) {
                    this.applyBuffer(previousBuffer);
                }
            }

            redo() {
                if (!this.undoManager.canRedo()) return;

                this.stop();
                const nextBuffer = this.undoManager.redo(this.audioEngine.audioBuffer);
                if (nextBuffer) {
                    this.applyBuffer(nextBuffer);
                }
            }

            applyBuffer(buffer) {
                this.audioEngine.setBuffer(buffer);
                this.waveformRenderer.setAudioBuffer(buffer);
                this.spectrogramRenderer.setAudioBuffer(buffer);
                this.metering.setAudioBuffer(buffer);
                this.updateFileInfo();
                this.updateUI();
                this.updateAnalysis();
            }

            saveStateForUndo() {
                this.undoManager.saveState(this.audioEngine.audioBuffer);
            }

            trim() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                this.saveStateForUndo();
                const newBuffer = this.audioEditor.trim(
                    this.audioEngine.audioBuffer,
                    selection.start,
                    selection.end
                );
                // Adjust cue points for the trim
                this.cuePointManager.adjustForTrim(selection.start, selection.end);
                this.applyBuffer(newBuffer);
                this.cuePointRenderer.render();
            }

            deleteSelection() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection || !this.audioEditor) return;

                this.stop();
                this.saveStateForUndo();
                const newBuffer = this.audioEditor.deleteSelection(
                    this.audioEngine.audioBuffer,
                    selection.start,
                    selection.end
                );

                if (newBuffer) {
                    // Adjust cue points for the deletion
                    this.cuePointManager.adjustForDeletion(selection.start, selection.end);
                    this.applyBuffer(newBuffer);
                    this.cuePointRenderer.render();
                }
            }

            showNormalizeModal() {
                document.getElementById('normalizeModal').classList.add('visible');
            }

            hideNormalizeModal() {
                document.getElementById('normalizeModal').classList.remove('visible');
            }

            normalize() {
                const level = parseFloat(document.getElementById('normalizeLevel').value);
                const selection = this.waveformRenderer.getSelection();

                this.stop();
                this.saveStateForUndo();
                if (selection) {
                    this.audioEditor.normalize(this.audioEngine.audioBuffer, level, selection.start, selection.end);
                } else {
                    this.audioEditor.normalize(this.audioEngine.audioBuffer, level);
                }
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.spectrogramRenderer.render();
                this.updateUI();
                this.updateAnalysis();
                this.hideNormalizeModal();
            }

            fadeIn() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                this.saveStateForUndo();
                this.audioEditor.fadeIn(this.audioEngine.audioBuffer, selection.start, selection.end);
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.spectrogramRenderer.render();
                this.updateUI();
                this.updateAnalysis();
            }

            fadeOut() {
                const selection = this.waveformRenderer.getSelection();
                if (!selection) return;

                this.stop();
                this.saveStateForUndo();
                this.audioEditor.fadeOut(this.audioEngine.audioBuffer, selection.start, selection.end);
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.spectrogramRenderer.render();
                this.updateUI();
                this.updateAnalysis();
            }

            reverse() {
                const selection = this.waveformRenderer.getSelection();

                this.stop();
                this.saveStateForUndo();
                if (selection) {
                    this.audioEditor.reverse(this.audioEngine.audioBuffer, selection.start, selection.end);
                } else {
                    this.audioEditor.reverse(this.audioEngine.audioBuffer);
                }
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.spectrogramRenderer.render();
                this.updateUI();
                this.updateAnalysis();
            }

            showGainModal() {
                document.getElementById('gainModal').classList.add('visible');
            }

            hideGainModal() {
                document.getElementById('gainModal').classList.remove('visible');
            }

            applyGain() {
                const gainDb = parseFloat(document.getElementById('gainAmount').value);
                const selection = this.waveformRenderer.getSelection();

                this.stop();
                this.saveStateForUndo();
                if (selection) {
                    this.audioEditor.applyGain(this.audioEngine.audioBuffer, gainDb, selection.start, selection.end);
                } else {
                    this.audioEditor.applyGain(this.audioEngine.audioBuffer, gainDb);
                }
                this.waveformRenderer.calculatePeaks();
                this.waveformRenderer.render();
                this.spectrogramRenderer.render();
                this.updateUI();
                this.updateAnalysis();
                this.hideGainModal();
            }

            showExportModal() {
                const hasSelection = this.waveformRenderer.hasSelection();
                const exportSelectionCheckbox = document.getElementById('exportSelection');
                exportSelectionCheckbox.disabled = !hasSelection;
                exportSelectionCheckbox.checked = hasSelection; // Auto-check if there's a selection
                document.getElementById('exportModal').classList.add('visible');
            }

            hideExportModal() {
                document.getElementById('exportModal').classList.remove('visible');
            }

            exportFile() {
                const format = document.getElementById('exportFormat').value;
                const bitDepth = parseInt(document.getElementById('exportBitDepth').value);
                const dither = document.getElementById('exportDither').value;
                const exportSelection = document.getElementById('exportSelection').checked;

                // Determine which buffer to export
                let bufferToExport = this.audioEngine.audioBuffer;
                let fileNameSuffix = '';

                if (exportSelection && this.waveformRenderer.hasSelection()) {
                    const selection = this.waveformRenderer.getSelection();
                    bufferToExport = this.audioEditor.trim(
                        this.audioEngine.audioBuffer,
                        selection.start,
                        selection.end
                    );
                    fileNameSuffix = '_selection';
                }

                let blob;
                let extension;

                if (format === 'wav') {
                    blob = FileHandler.exportWAV(bufferToExport, bitDepth, dither);
                    extension = '.wav';
                } else {
                    // AIF doesn't support 32-bit float
                    const aifBitDepth = bitDepth === 32 ? 24 : bitDepth;
                    blob = FileHandler.exportAIF(bufferToExport, aifBitDepth, dither);
                    extension = '.aif';
                }

                const baseName = this.fileName ? this.fileName.replace(/\.[^/.]+$/, '') : 'audio';
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = baseName + fileNameSuffix + extension;
                a.click();
                URL.revokeObjectURL(url);

                this.hideExportModal();
            }

            updateUI() {
                const hasAudio = !!this.audioEngine.audioBuffer;
                const hasSelection = this.waveformRenderer.hasSelection();
                const isPlaying = this.audioEngine.isPlaying;

                // File buttons
                document.getElementById('exportBtn').disabled = !hasAudio;
                document.getElementById('saveProjectBtn').disabled = !hasAudio;

                // Markers
                document.getElementById('addCueBtn').disabled = !hasAudio;

                // Transport
                document.getElementById('playBtn').disabled = !hasAudio;
                document.getElementById('pauseBtn').disabled = !isPlaying;
                document.getElementById('stopBtn').disabled = !hasAudio;
                document.getElementById('loopBtn').disabled = !hasAudio;
                document.getElementById('playBtn').classList.toggle('playing', isPlaying);

                // Zoom
                document.getElementById('zoomInBtn').disabled = !hasAudio;
                document.getElementById('zoomOutBtn').disabled = !hasAudio;
                document.getElementById('zoomFitBtn').disabled = !hasAudio;

                // Edit (require selection for most)
                document.getElementById('undoBtn').disabled = !this.undoManager.canUndo();
                document.getElementById('redoBtn').disabled = !this.undoManager.canRedo();
                document.getElementById('trimBtn').disabled = !hasSelection;
                document.getElementById('normalizeBtn').disabled = !hasAudio;
                document.getElementById('fadeInBtn').disabled = !hasSelection;
                document.getElementById('fadeOutBtn').disabled = !hasSelection;
                document.getElementById('gainBtn').disabled = !hasAudio;
                document.getElementById('reverseBtn').disabled = !hasAudio;
            }

            addCuePointAtPlayhead() {
                if (!this.audioEngine.audioBuffer) return;

                const sample = this.waveformRenderer.playheadPosition;

                // Show name input popup
                const cuepointInput = document.getElementById('cuepointInput');
                const cuepointNameInput = document.getElementById('cuepointNameInput');

                // Position the input near the playhead
                const playheadX = this.cuePointRenderer.sampleToPixel(sample);
                cuepointInput.style.left = Math.max(10, Math.min(playheadX, this.cuePointRenderer.width - 150)) + 'px';
                cuepointInput.style.top = '4px';

                this.pendingCuePointSample = sample;
                cuepointInput.classList.add('visible');
                cuepointNameInput.focus();
            }

            async saveProject() {
                if (!this.audioEngine.audioBuffer) return;

                try {
                    const jsonString = await ProjectManager.saveProject(
                        this.audioEngine.audioBuffer,
                        this.cuePointManager,
                        this.fileName,
                        { savedAt: new Date().toISOString() }
                    );
                    ProjectManager.downloadProject(jsonString, this.fileName);
                } catch (err) {
                    alert('Error saving project: ' + err.message);
                }
            }

            async loadProject(file) {
                try {
                    const text = await file.text();
                    await this.audioEngine.init();

                    const project = await ProjectManager.loadProject(text, this.audioEngine.audioContext);

                    // Set up audio editor if needed
                    if (!this.audioEditor) {
                        this.audioEditor = new AudioEditor(this.audioEngine.audioContext);
                    }

                    // Set up undo manager
                    this.undoManager.setAudioContext(this.audioEngine.audioContext);
                    this.undoManager.clear();

                    // Set the audio buffer
                    this.audioEngine.setBuffer(project.audioBuffer);
                    this.fileName = project.fileName || 'Untitled';

                    // Set up waveform
                    this.waveformRenderer.setAudioBuffer(project.audioBuffer);

                    // Set up spectrogram
                    this.spectrogramRenderer.setAudioBuffer(project.audioBuffer);
                    this.spectrogramRenderer.setAnalyserNode(this.audioEngine.getAnalyserNode());
                    this.spectrogramRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);

                    // Set up metering
                    this.metering.setAudioBuffer(project.audioBuffer);
                    this.metering.setAnalyserNode(this.audioEngine.getAnalyserNode());

                    // Load cue points
                    this.cuePointManager.fromJSON(project.cuePoints);
                    this.cuePointRenderer.setAudioBuffer(project.audioBuffer);
                    this.cuePointRenderer.setSamplesPerPixel(this.waveformRenderer.samplesPerPixel);
                    this.cuePointRenderer.setScrollOffset(this.waveformRenderer.scrollOffset);

                    this.updateUI();
                    this.updateFileInfo();
                    this.updateZoomInfo();
                    this.updateAnalysis();
                } catch (err) {
                    alert('Error loading project: ' + err.message);
                }
            }

            updateFileInfo() {
                const buffer = this.audioEngine.audioBuffer;
                if (!buffer) {
                    document.getElementById('fileInfo').textContent = 'No file loaded';
                    return;
                }

                const duration = formatTime(buffer.duration);
                const sampleRate = (buffer.sampleRate / 1000).toFixed(1) + ' kHz';
                const channels = buffer.numberOfChannels === 1 ? 'Mono' : 'Stereo';

                document.getElementById('fileInfo').textContent =
                    `${this.fileName} | ${duration} | ${sampleRate} | ${channels}`;
            }

            updatePositionInfo(time) {
                document.getElementById('positionInfo').textContent = formatTime(time);
            }

            updateZoomInfo() {
                const spp = this.waveformRenderer.samplesPerPixel;
                let zoomText;
                if (spp >= 1000) {
                    zoomText = (spp / 1000).toFixed(1) + 'k samples/px';
                } else {
                    zoomText = spp.toFixed(0) + ' samples/px';
                }
                document.getElementById('zoomInfo').textContent = zoomText;
            }
        }

        // Start the application
        const app = new App();
    </script>
</body>
</html>
